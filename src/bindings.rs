/* automatically generated by rust-bindgen 0.72.1 */

pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2Y: u32 = 0;
pub const __GLIBC_USE_ISOC23: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_TIME_BITS64: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const __GLIBC_USE_C23_STRTOL: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 42;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C23: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C23: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const _BITS_STDINT_LEAST_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const _ASSERT_H: u32 = 1;
pub const _INTTYPES_H: u32 = 1;
pub const ____gwchar_t_defined: u32 = 1;
pub const __PRI64_PREFIX: &[u8; 2] = b"l\0";
pub const __PRIPTR_PREFIX: &[u8; 2] = b"l\0";
pub const PRId8: &[u8; 2] = b"d\0";
pub const PRId16: &[u8; 2] = b"d\0";
pub const PRId32: &[u8; 2] = b"d\0";
pub const PRId64: &[u8; 3] = b"ld\0";
pub const PRIdLEAST8: &[u8; 2] = b"d\0";
pub const PRIdLEAST16: &[u8; 2] = b"d\0";
pub const PRIdLEAST32: &[u8; 2] = b"d\0";
pub const PRIdLEAST64: &[u8; 3] = b"ld\0";
pub const PRIdFAST8: &[u8; 2] = b"d\0";
pub const PRIdFAST16: &[u8; 3] = b"ld\0";
pub const PRIdFAST32: &[u8; 3] = b"ld\0";
pub const PRIdFAST64: &[u8; 3] = b"ld\0";
pub const PRIi8: &[u8; 2] = b"i\0";
pub const PRIi16: &[u8; 2] = b"i\0";
pub const PRIi32: &[u8; 2] = b"i\0";
pub const PRIi64: &[u8; 3] = b"li\0";
pub const PRIiLEAST8: &[u8; 2] = b"i\0";
pub const PRIiLEAST16: &[u8; 2] = b"i\0";
pub const PRIiLEAST32: &[u8; 2] = b"i\0";
pub const PRIiLEAST64: &[u8; 3] = b"li\0";
pub const PRIiFAST8: &[u8; 2] = b"i\0";
pub const PRIiFAST16: &[u8; 3] = b"li\0";
pub const PRIiFAST32: &[u8; 3] = b"li\0";
pub const PRIiFAST64: &[u8; 3] = b"li\0";
pub const PRIo8: &[u8; 2] = b"o\0";
pub const PRIo16: &[u8; 2] = b"o\0";
pub const PRIo32: &[u8; 2] = b"o\0";
pub const PRIo64: &[u8; 3] = b"lo\0";
pub const PRIoLEAST8: &[u8; 2] = b"o\0";
pub const PRIoLEAST16: &[u8; 2] = b"o\0";
pub const PRIoLEAST32: &[u8; 2] = b"o\0";
pub const PRIoLEAST64: &[u8; 3] = b"lo\0";
pub const PRIoFAST8: &[u8; 2] = b"o\0";
pub const PRIoFAST16: &[u8; 3] = b"lo\0";
pub const PRIoFAST32: &[u8; 3] = b"lo\0";
pub const PRIoFAST64: &[u8; 3] = b"lo\0";
pub const PRIu8: &[u8; 2] = b"u\0";
pub const PRIu16: &[u8; 2] = b"u\0";
pub const PRIu32: &[u8; 2] = b"u\0";
pub const PRIu64: &[u8; 3] = b"lu\0";
pub const PRIuLEAST8: &[u8; 2] = b"u\0";
pub const PRIuLEAST16: &[u8; 2] = b"u\0";
pub const PRIuLEAST32: &[u8; 2] = b"u\0";
pub const PRIuLEAST64: &[u8; 3] = b"lu\0";
pub const PRIuFAST8: &[u8; 2] = b"u\0";
pub const PRIuFAST16: &[u8; 3] = b"lu\0";
pub const PRIuFAST32: &[u8; 3] = b"lu\0";
pub const PRIuFAST64: &[u8; 3] = b"lu\0";
pub const PRIx8: &[u8; 2] = b"x\0";
pub const PRIx16: &[u8; 2] = b"x\0";
pub const PRIx32: &[u8; 2] = b"x\0";
pub const PRIx64: &[u8; 3] = b"lx\0";
pub const PRIxLEAST8: &[u8; 2] = b"x\0";
pub const PRIxLEAST16: &[u8; 2] = b"x\0";
pub const PRIxLEAST32: &[u8; 2] = b"x\0";
pub const PRIxLEAST64: &[u8; 3] = b"lx\0";
pub const PRIxFAST8: &[u8; 2] = b"x\0";
pub const PRIxFAST16: &[u8; 3] = b"lx\0";
pub const PRIxFAST32: &[u8; 3] = b"lx\0";
pub const PRIxFAST64: &[u8; 3] = b"lx\0";
pub const PRIX8: &[u8; 2] = b"X\0";
pub const PRIX16: &[u8; 2] = b"X\0";
pub const PRIX32: &[u8; 2] = b"X\0";
pub const PRIX64: &[u8; 3] = b"lX\0";
pub const PRIXLEAST8: &[u8; 2] = b"X\0";
pub const PRIXLEAST16: &[u8; 2] = b"X\0";
pub const PRIXLEAST32: &[u8; 2] = b"X\0";
pub const PRIXLEAST64: &[u8; 3] = b"lX\0";
pub const PRIXFAST8: &[u8; 2] = b"X\0";
pub const PRIXFAST16: &[u8; 3] = b"lX\0";
pub const PRIXFAST32: &[u8; 3] = b"lX\0";
pub const PRIXFAST64: &[u8; 3] = b"lX\0";
pub const PRIdMAX: &[u8; 3] = b"ld\0";
pub const PRIiMAX: &[u8; 3] = b"li\0";
pub const PRIoMAX: &[u8; 3] = b"lo\0";
pub const PRIuMAX: &[u8; 3] = b"lu\0";
pub const PRIxMAX: &[u8; 3] = b"lx\0";
pub const PRIXMAX: &[u8; 3] = b"lX\0";
pub const PRIdPTR: &[u8; 3] = b"ld\0";
pub const PRIiPTR: &[u8; 3] = b"li\0";
pub const PRIoPTR: &[u8; 3] = b"lo\0";
pub const PRIuPTR: &[u8; 3] = b"lu\0";
pub const PRIxPTR: &[u8; 3] = b"lx\0";
pub const PRIXPTR: &[u8; 3] = b"lX\0";
pub const SCNd8: &[u8; 4] = b"hhd\0";
pub const SCNd16: &[u8; 3] = b"hd\0";
pub const SCNd32: &[u8; 2] = b"d\0";
pub const SCNd64: &[u8; 3] = b"ld\0";
pub const SCNdLEAST8: &[u8; 4] = b"hhd\0";
pub const SCNdLEAST16: &[u8; 3] = b"hd\0";
pub const SCNdLEAST32: &[u8; 2] = b"d\0";
pub const SCNdLEAST64: &[u8; 3] = b"ld\0";
pub const SCNdFAST8: &[u8; 4] = b"hhd\0";
pub const SCNdFAST16: &[u8; 3] = b"ld\0";
pub const SCNdFAST32: &[u8; 3] = b"ld\0";
pub const SCNdFAST64: &[u8; 3] = b"ld\0";
pub const SCNi8: &[u8; 4] = b"hhi\0";
pub const SCNi16: &[u8; 3] = b"hi\0";
pub const SCNi32: &[u8; 2] = b"i\0";
pub const SCNi64: &[u8; 3] = b"li\0";
pub const SCNiLEAST8: &[u8; 4] = b"hhi\0";
pub const SCNiLEAST16: &[u8; 3] = b"hi\0";
pub const SCNiLEAST32: &[u8; 2] = b"i\0";
pub const SCNiLEAST64: &[u8; 3] = b"li\0";
pub const SCNiFAST8: &[u8; 4] = b"hhi\0";
pub const SCNiFAST16: &[u8; 3] = b"li\0";
pub const SCNiFAST32: &[u8; 3] = b"li\0";
pub const SCNiFAST64: &[u8; 3] = b"li\0";
pub const SCNu8: &[u8; 4] = b"hhu\0";
pub const SCNu16: &[u8; 3] = b"hu\0";
pub const SCNu32: &[u8; 2] = b"u\0";
pub const SCNu64: &[u8; 3] = b"lu\0";
pub const SCNuLEAST8: &[u8; 4] = b"hhu\0";
pub const SCNuLEAST16: &[u8; 3] = b"hu\0";
pub const SCNuLEAST32: &[u8; 2] = b"u\0";
pub const SCNuLEAST64: &[u8; 3] = b"lu\0";
pub const SCNuFAST8: &[u8; 4] = b"hhu\0";
pub const SCNuFAST16: &[u8; 3] = b"lu\0";
pub const SCNuFAST32: &[u8; 3] = b"lu\0";
pub const SCNuFAST64: &[u8; 3] = b"lu\0";
pub const SCNo8: &[u8; 4] = b"hho\0";
pub const SCNo16: &[u8; 3] = b"ho\0";
pub const SCNo32: &[u8; 2] = b"o\0";
pub const SCNo64: &[u8; 3] = b"lo\0";
pub const SCNoLEAST8: &[u8; 4] = b"hho\0";
pub const SCNoLEAST16: &[u8; 3] = b"ho\0";
pub const SCNoLEAST32: &[u8; 2] = b"o\0";
pub const SCNoLEAST64: &[u8; 3] = b"lo\0";
pub const SCNoFAST8: &[u8; 4] = b"hho\0";
pub const SCNoFAST16: &[u8; 3] = b"lo\0";
pub const SCNoFAST32: &[u8; 3] = b"lo\0";
pub const SCNoFAST64: &[u8; 3] = b"lo\0";
pub const SCNx8: &[u8; 4] = b"hhx\0";
pub const SCNx16: &[u8; 3] = b"hx\0";
pub const SCNx32: &[u8; 2] = b"x\0";
pub const SCNx64: &[u8; 3] = b"lx\0";
pub const SCNxLEAST8: &[u8; 4] = b"hhx\0";
pub const SCNxLEAST16: &[u8; 3] = b"hx\0";
pub const SCNxLEAST32: &[u8; 2] = b"x\0";
pub const SCNxLEAST64: &[u8; 3] = b"lx\0";
pub const SCNxFAST8: &[u8; 4] = b"hhx\0";
pub const SCNxFAST16: &[u8; 3] = b"lx\0";
pub const SCNxFAST32: &[u8; 3] = b"lx\0";
pub const SCNxFAST64: &[u8; 3] = b"lx\0";
pub const SCNdMAX: &[u8; 3] = b"ld\0";
pub const SCNiMAX: &[u8; 3] = b"li\0";
pub const SCNoMAX: &[u8; 3] = b"lo\0";
pub const SCNuMAX: &[u8; 3] = b"lu\0";
pub const SCNxMAX: &[u8; 3] = b"lx\0";
pub const SCNdPTR: &[u8; 3] = b"ld\0";
pub const SCNiPTR: &[u8; 3] = b"li\0";
pub const SCNoPTR: &[u8; 3] = b"lo\0";
pub const SCNuPTR: &[u8; 3] = b"lu\0";
pub const SCNxPTR: &[u8; 3] = b"lx\0";
pub const DART_FLAGS_CURRENT_VERSION: u32 = 13;
pub const DART_INITIALIZE_PARAMS_CURRENT_VERSION: u32 = 9;
pub const DART_KERNEL_ISOLATE_NAME: &[u8; 15] = b"kernel-service\0";
pub const DART_VM_SERVICE_ISOLATE_NAME: &[u8; 11] = b"vm-service\0";
pub const kSnapshotBuildIdCSymbol: &[u8; 22] = b"_kDartSnapshotBuildId\0";
pub const kVmSnapshotDataCSymbol: &[u8; 21] = b"_kDartVmSnapshotData\0";
pub const kVmSnapshotInstructionsCSymbol: &[u8; 29] = b"_kDartVmSnapshotInstructions\0";
pub const kVmSnapshotBssCSymbol: &[u8; 20] = b"_kDartVmSnapshotBss\0";
pub const kIsolateSnapshotDataCSymbol: &[u8; 26] = b"_kDartIsolateSnapshotData\0";
pub const kIsolateSnapshotInstructionsCSymbol: &[u8; 34] = b"_kDartIsolateSnapshotInstructions\0";
pub const kIsolateSnapshotBssCSymbol: &[u8; 25] = b"_kDartIsolateSnapshotBss\0";
pub const kSnapshotBuildIdAsmSymbol: &[u8; 22] = b"_kDartSnapshotBuildId\0";
pub const kVmSnapshotDataAsmSymbol: &[u8; 21] = b"_kDartVmSnapshotData\0";
pub const kVmSnapshotInstructionsAsmSymbol: &[u8; 29] = b"_kDartVmSnapshotInstructions\0";
pub const kVmSnapshotBssAsmSymbol: &[u8; 20] = b"_kDartVmSnapshotBss\0";
pub const kIsolateSnapshotDataAsmSymbol: &[u8; 26] = b"_kDartIsolateSnapshotData\0";
pub const kIsolateSnapshotInstructionsAsmSymbol: &[u8; 34] = b"_kDartIsolateSnapshotInstructions\0";
pub const kIsolateSnapshotBssAsmSymbol: &[u8; 25] = b"_kDartIsolateSnapshotBss\0";
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __fsid_t"][::std::mem::size_of::<__fsid_t>() - 8usize];
    ["Alignment of __fsid_t"][::std::mem::align_of::<__fsid_t>() - 4usize];
    ["Offset of field: __fsid_t::__val"][::std::mem::offset_of!(__fsid_t, __val) - 0usize];
};
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Dart_Isolate {
    _unused: [u8; 0],
}
#[doc = " An isolate is the unit of concurrency in Dart. Each isolate has\n its own memory and thread of control. No state is shared between\n isolates. Instead, isolates communicate by message passing.\n\n Each thread keeps track of its current isolate, which is the\n isolate which is ready to execute on the current thread. The\n current isolate may be NULL, in which case no isolate is ready to\n execute. Most of the Dart apis require there to be a current\n isolate in order to function without error. The current isolate is\n set by any call to Dart_CreateIsolateGroup or Dart_EnterIsolate."]
pub type Dart_Isolate = *mut _Dart_Isolate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Dart_Handle {
    _unused: [u8; 0],
}
#[doc = " An object reference managed by the Dart VM garbage collector.\n\n Because the garbage collector may move objects, it is unsafe to\n refer to objects directly. Instead, we refer to objects through\n handles, which are known to the garbage collector and updated\n automatically when the object is moved. Handles should be passed\n by value (except in cases like out-parameters) and should never be\n allocated on the heap.\n\n Most functions in the Dart Embedding API return a handle. When a\n function completes normally, this will be a valid handle to an\n object in the Dart VM heap. This handle may represent the result of\n the operation or it may be a special valid handle used merely to\n indicate successful completion. Note that a valid handle may in\n some cases refer to the null object.\n\n --- Error handles ---\n\n When a function encounters a problem that prevents it from\n completing normally, it returns an error handle (See Dart_IsError).\n An error handle has an associated error message that gives more\n details about the problem (See Dart_GetError).\n\n There are four kinds of error handles that can be produced,\n depending on what goes wrong:\n\n - Api error handles are produced when an api function is misused.\n   This happens when a Dart embedding api function is called with\n   invalid arguments or in an invalid context.\n\n - Unhandled exception error handles are produced when, during the\n   execution of Dart code, an exception is thrown but not caught.\n   Prototypically this would occur during a call to Dart_Invoke, but\n   it can occur in any function which triggers the execution of Dart\n   code (for example, Dart_ToString).\n\n   An unhandled exception error provides access to an exception and\n   stacktrace via the functions Dart_ErrorGetException and\n   Dart_ErrorGetStackTrace.\n\n - Compilation error handles are produced when, during the execution\n   of Dart code, a compile-time error occurs.  As above, this can\n   occur in any function which triggers the execution of Dart code.\n\n - Fatal error handles are produced when the system wants to shut\n   down the current isolate.\n\n --- Propagating errors ---\n\n When an error handle is returned from the top level invocation of\n Dart code in a program, the embedder must handle the error as they\n see fit.  Often, the embedder will print the error message produced\n by Dart_Error and exit the program.\n\n When an error is returned while in the body of a native function,\n it can be propagated up the call stack by calling\n Dart_PropagateError, Dart_SetReturnValue, or Dart_ThrowException.\n Errors should be propagated unless there is a specific reason not\n to.  If an error is not propagated then it is ignored.  For\n example, if an unhandled exception error is ignored, that\n effectively \"catches\" the unhandled exception.  Fatal errors must\n always be propagated.\n\n When an error is propagated, any current scopes created by\n Dart_EnterScope will be exited.\n\n Using Dart_SetReturnValue to propagate an exception is somewhat\n more convenient than using Dart_PropagateError, and should be\n preferred for reasons discussed below.\n\n Dart_PropagateError and Dart_ThrowException do not return.  Instead\n they transfer control non-locally using a setjmp-like mechanism.\n This can be inconvenient if you have resources that you need to\n clean up before propagating the error.\n\n When relying on Dart_PropagateError, we often return error handles\n rather than propagating them from helper functions.  Consider the\n following contrived example:\n\n 1    Dart_Handle isLongStringHelper(Dart_Handle arg) {\n 2      intptr_t* length = 0;\n 3      result = Dart_StringLength(arg, &length);\n 4      if (Dart_IsError(result)) {\n 5        return result;\n 6      }\n 7      return Dart_NewBoolean(length > 100);\n 8    }\n 9\n 10   void NativeFunction_isLongString(Dart_NativeArguments args) {\n 11     Dart_EnterScope();\n 12     AllocateMyResource();\n 13     Dart_Handle arg = Dart_GetNativeArgument(args, 0);\n 14     Dart_Handle result = isLongStringHelper(arg);\n 15     if (Dart_IsError(result)) {\n 16       FreeMyResource();\n 17       Dart_PropagateError(result);\n 18       abort();  // will not reach here\n 19     }\n 20     Dart_SetReturnValue(result);\n 21     FreeMyResource();\n 22     Dart_ExitScope();\n 23   }\n\n In this example, we have a native function which calls a helper\n function to do its work.  On line 5, the helper function could call\n Dart_PropagateError, but that would not give the native function a\n chance to call FreeMyResource(), causing a leak.  Instead, the\n helper function returns the error handle to the caller, giving the\n caller a chance to clean up before propagating the error handle.\n\n When an error is propagated by calling Dart_SetReturnValue, the\n native function will be allowed to complete normally and then the\n exception will be propagated only once the native call\n returns. This can be convenient, as it allows the C code to clean\n up normally.\n\n The example can be written more simply using Dart_SetReturnValue to\n propagate the error.\n\n 1    Dart_Handle isLongStringHelper(Dart_Handle arg) {\n 2      intptr_t* length = 0;\n 3      result = Dart_StringLength(arg, &length);\n 4      if (Dart_IsError(result)) {\n 5        return result\n 6      }\n 7      return Dart_NewBoolean(length > 100);\n 8    }\n 9\n 10   void NativeFunction_isLongString(Dart_NativeArguments args) {\n 11     Dart_EnterScope();\n 12     AllocateMyResource();\n 13     Dart_Handle arg = Dart_GetNativeArgument(args, 0);\n 14     Dart_SetReturnValue(isLongStringHelper(arg));\n 15     FreeMyResource();\n 16     Dart_ExitScope();\n 17   }\n\n In this example, the call to Dart_SetReturnValue on line 14 will\n either return the normal return value or the error (potentially\n generated on line 3).  The call to FreeMyResource on line 15 will\n execute in either case.\n\n --- Local and persistent handles ---\n\n Local handles are allocated within the current scope (see\n Dart_EnterScope) and go away when the current scope exits. Unless\n otherwise indicated, callers should assume that all functions in\n the Dart embedding api return local handles.\n\n Persistent handles are allocated within the current isolate. They\n can be used to store objects across scopes. Persistent handles have\n the lifetime of the current isolate unless they are explicitly\n deallocated (see Dart_DeletePersistentHandle).\n The type Dart_Handle represents a handle (both local and persistent).\n The type Dart_PersistentHandle is a Dart_Handle and it is used to\n document that a persistent handle is expected as a parameter to a call\n or the return value from a call is a persistent handle.\n\n FinalizableHandles are persistent handles which are auto deleted when\n the object is garbage collected. It is never safe to use these handles\n unless you know the object is still reachable.\n\n WeakPersistentHandles are persistent handles which are automatically set\n to point Dart_Null when the object is garbage collected. They are not auto\n deleted, so it is safe to use them after the object has become unreachable."]
pub type Dart_Handle = *mut _Dart_Handle;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DartDllConfig {
    pub start_service_isolate: bool,
    pub service_port: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of DartDllConfig"][::std::mem::size_of::<DartDllConfig>() - 8usize];
    ["Alignment of DartDllConfig"][::std::mem::align_of::<DartDllConfig>() - 4usize];
    ["Offset of field: DartDllConfig::start_service_isolate"]
        [::std::mem::offset_of!(DartDllConfig, start_service_isolate) - 0usize];
    ["Offset of field: DartDllConfig::service_port"]
        [::std::mem::offset_of!(DartDllConfig, service_port) - 4usize];
};
unsafe extern "C" {
    pub fn DartDll_Initialize(config: *const DartDllConfig) -> bool;
}
unsafe extern "C" {
    pub fn DartDll_LoadScript(
        script_uri: *const ::std::os::raw::c_char,
        package_config: *const ::std::os::raw::c_char,
        isolate_data: *mut ::std::os::raw::c_void,
    ) -> Dart_Isolate;
}
unsafe extern "C" {
    pub fn DartDll_GetUserIsolateData(
        isolate_group_data: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn DartDll_RunMain(library: Dart_Handle) -> Dart_Handle;
}
unsafe extern "C" {
    pub fn DartDll_DrainMicrotaskQueue() -> Dart_Handle;
}
unsafe extern "C" {
    pub fn DartDll_Shutdown() -> bool;
}
unsafe extern "C" {
    pub fn __assert_fail(
        __assertion: *const ::std::os::raw::c_char,
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_uint,
        __function: *const ::std::os::raw::c_char,
    ) -> !;
}
unsafe extern "C" {
    pub fn __assert_perror_fail(
        __errnum: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_uint,
        __function: *const ::std::os::raw::c_char,
    ) -> !;
}
unsafe extern "C" {
    pub fn __assert(
        __assertion: *const ::std::os::raw::c_char,
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_int,
    ) -> !;
}
pub type __gwchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of imaxdiv_t"][::std::mem::size_of::<imaxdiv_t>() - 16usize];
    ["Alignment of imaxdiv_t"][::std::mem::align_of::<imaxdiv_t>() - 8usize];
    ["Offset of field: imaxdiv_t::quot"][::std::mem::offset_of!(imaxdiv_t, quot) - 0usize];
    ["Offset of field: imaxdiv_t::rem"][::std::mem::offset_of!(imaxdiv_t, rem) - 8usize];
};
unsafe extern "C" {
    pub fn imaxabs(__n: intmax_t) -> intmax_t;
}
unsafe extern "C" {
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
}
unsafe extern "C" {
    pub fn strtoimax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
unsafe extern "C" {
    pub fn strtoumax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
unsafe extern "C" {
    pub fn wcstoimax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
unsafe extern "C" {
    pub fn wcstoumax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Dart_IsolateGroup {
    _unused: [u8; 0],
}
pub type Dart_IsolateGroup = *mut _Dart_IsolateGroup;
pub type Dart_PersistentHandle = Dart_Handle;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Dart_WeakPersistentHandle {
    _unused: [u8; 0],
}
pub type Dart_WeakPersistentHandle = *mut _Dart_WeakPersistentHandle;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Dart_FinalizableHandle {
    _unused: [u8; 0],
}
pub type Dart_FinalizableHandle = *mut _Dart_FinalizableHandle;
pub type Dart_HandleFinalizer = ::std::option::Option<
    unsafe extern "C" fn(
        isolate_callback_data: *mut ::std::os::raw::c_void,
        peer: *mut ::std::os::raw::c_void,
    ),
>;
unsafe extern "C" {
    #[doc = " Is this an error handle?\n\n Requires there to be a current isolate."]
    pub fn Dart_IsError(handle: Dart_Handle) -> bool;
}
unsafe extern "C" {
    #[doc = " Is this an api error handle?\n\n Api error handles are produced when an api function is misused.\n This happens when a Dart embedding api function is called with\n invalid arguments or in an invalid context.\n\n Requires there to be a current isolate."]
    pub fn Dart_IsApiError(handle: Dart_Handle) -> bool;
}
unsafe extern "C" {
    #[doc = " Is this an unhandled exception error handle?\n\n Unhandled exception error handles are produced when, during the\n execution of Dart code, an exception is thrown but not caught.\n This can occur in any function which triggers the execution of Dart\n code.\n\n See Dart_ErrorGetException and Dart_ErrorGetStackTrace.\n\n Requires there to be a current isolate."]
    pub fn Dart_IsUnhandledExceptionError(handle: Dart_Handle) -> bool;
}
unsafe extern "C" {
    #[doc = " Is this a compilation error handle?\n\n Compilation error handles are produced when, during the execution\n of Dart code, a compile-time error occurs.  This can occur in any\n function which triggers the execution of Dart code.\n\n Requires there to be a current isolate."]
    pub fn Dart_IsCompilationError(handle: Dart_Handle) -> bool;
}
unsafe extern "C" {
    #[doc = " Is this a fatal error handle?\n\n Fatal error handles are produced when the system wants to shut down\n the current isolate.\n\n Requires there to be a current isolate."]
    pub fn Dart_IsFatalError(handle: Dart_Handle) -> bool;
}
unsafe extern "C" {
    #[doc = " Gets the error message from an error handle.\n\n Requires there to be a current isolate.\n\n \\return A C string containing an error message if the handle is\n   error. An empty C string (\"\") if the handle is valid. This C\n   String is scope allocated and is only valid until the next call\n   to Dart_ExitScope."]
    pub fn Dart_GetError(handle: Dart_Handle) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Is this an error handle for an unhandled exception?"]
    pub fn Dart_ErrorHasException(handle: Dart_Handle) -> bool;
}
unsafe extern "C" {
    #[doc = " Gets the exception Object from an unhandled exception error handle."]
    pub fn Dart_ErrorGetException(handle: Dart_Handle) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Gets the stack trace Object from an unhandled exception error handle."]
    pub fn Dart_ErrorGetStackTrace(handle: Dart_Handle) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Produces an api error handle with the provided error message.\n\n Requires there to be a current isolate.\n\n \\param error the error message."]
    pub fn Dart_NewApiError(error: *const ::std::os::raw::c_char) -> Dart_Handle;
}
unsafe extern "C" {
    pub fn Dart_NewCompilationError(error: *const ::std::os::raw::c_char) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Produces a new unhandled exception error handle.\n\n Requires there to be a current isolate.\n\n \\param exception An instance of a Dart object to be thrown or\n        an ApiError or CompilationError handle.\n        When an ApiError or CompilationError handle is passed in\n        a string object of the error message is created and it becomes\n        the Dart object to be thrown."]
    pub fn Dart_NewUnhandledExceptionError(exception: Dart_Handle) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Propagates an error.\n\n If the provided handle is an unhandled exception error, this\n function will cause the unhandled exception to be rethrown.  This\n will proceed in the standard way, walking up Dart frames until an\n appropriate 'catch' block is found, executing 'finally' blocks,\n etc.\n\n If the error is not an unhandled exception error, we will unwind\n the stack to the next C frame.  Intervening Dart frames will be\n discarded; specifically, 'finally' blocks will not execute.  This\n is the standard way that compilation errors (and the like) are\n handled by the Dart runtime.\n\n In either case, when an error is propagated any current scopes\n created by Dart_EnterScope will be exited.\n\n See the additional discussion under \"Propagating Errors\" at the\n beginning of this file.\n\n \\param handle An error handle (See Dart_IsError)\n\n On success, this function does not return.  On failure, the\n process is terminated."]
    pub fn Dart_PropagateError(handle: Dart_Handle);
}
unsafe extern "C" {
    #[doc = " Converts an object to a string.\n\n May generate an unhandled exception error.\n\n \\return The converted string if no error occurs during\n   the conversion. If an error does occur, an error handle is\n   returned."]
    pub fn Dart_ToString(object: Dart_Handle) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Checks to see if two handles refer to identically equal objects.\n\n If both handles refer to instances, this is equivalent to using the top-level\n function identical() from dart:core. Otherwise, returns whether the two\n argument handles refer to the same object.\n\n \\param obj1 An object to be compared.\n \\param obj2 An object to be compared.\n\n \\return True if the objects are identically equal.  False otherwise."]
    pub fn Dart_IdentityEquals(obj1: Dart_Handle, obj2: Dart_Handle) -> bool;
}
unsafe extern "C" {
    #[doc = " Allocates a handle in the current scope from a persistent handle."]
    pub fn Dart_HandleFromPersistent(object: Dart_PersistentHandle) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Allocates a handle in the current scope from a weak persistent handle.\n\n This will be a handle to Dart_Null if the object has been garbage collected."]
    pub fn Dart_HandleFromWeakPersistent(object: Dart_WeakPersistentHandle) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Allocates a persistent handle for an object.\n\n This handle has the lifetime of the current isolate unless it is\n explicitly deallocated by calling Dart_DeletePersistentHandle.\n\n Requires there to be a current isolate."]
    pub fn Dart_NewPersistentHandle(object: Dart_Handle) -> Dart_PersistentHandle;
}
unsafe extern "C" {
    #[doc = " Assign value of local handle to a persistent handle.\n\n Requires there to be a current isolate.\n\n \\param obj1 A persistent handle whose value needs to be set.\n \\param obj2 An object whose value needs to be set to the persistent handle."]
    pub fn Dart_SetPersistentHandle(obj1: Dart_PersistentHandle, obj2: Dart_Handle);
}
unsafe extern "C" {
    #[doc = " Deallocates a persistent handle.\n\n Requires there to be a current isolate group."]
    pub fn Dart_DeletePersistentHandle(object: Dart_PersistentHandle);
}
unsafe extern "C" {
    #[doc = " Allocates a weak persistent handle for an object.\n\n This handle has the lifetime of the current isolate. The handle can also be\n explicitly deallocated by calling Dart_DeleteWeakPersistentHandle.\n\n If the object becomes unreachable the callback is invoked with the peer as\n argument. The callback can be executed on any thread, will have a current\n isolate group, but will not have a current isolate. The callback can only\n call Dart_DeletePersistentHandle or Dart_DeleteWeakPersistentHandle. This\n gives the embedder the ability to cleanup data associated with the object.\n The handle will point to the Dart_Null object after the finalizer has been\n run. It is illegal to call into the VM with any other Dart_* functions from\n the callback. If the handle is deleted before the object becomes\n unreachable, the callback is never invoked.\n\n Requires there to be a current isolate.\n\n \\param object An object with identity.\n \\param peer A pointer to a native object or NULL.  This value is\n   provided to callback when it is invoked.\n \\param external_allocation_size The number of externally allocated\n   bytes for peer. Used to inform the garbage collector.\n \\param callback A function pointer that will be invoked sometime\n   after the object is garbage collected, unless the handle has been deleted.\n   A valid callback needs to be specified it cannot be NULL.\n\n \\return The weak persistent handle or NULL. NULL is returned in case of bad\n   parameters."]
    pub fn Dart_NewWeakPersistentHandle(
        object: Dart_Handle,
        peer: *mut ::std::os::raw::c_void,
        external_allocation_size: isize,
        callback: Dart_HandleFinalizer,
    ) -> Dart_WeakPersistentHandle;
}
unsafe extern "C" {
    #[doc = " Deletes the given weak persistent [object] handle.\n\n Requires there to be a current isolate group."]
    pub fn Dart_DeleteWeakPersistentHandle(object: Dart_WeakPersistentHandle);
}
unsafe extern "C" {
    #[doc = " Allocates a finalizable handle for an object.\n\n This handle has the lifetime of the current isolate group unless the object\n pointed to by the handle is garbage collected, in this case the VM\n automatically deletes the handle after invoking the callback associated\n with the handle. The handle can also be explicitly deallocated by\n calling Dart_DeleteFinalizableHandle.\n\n If the object becomes unreachable the callback is invoked with the\n the peer as argument. The callback can be executed on any thread, will have\n an isolate group, but will not have a current isolate. The callback can only\n call Dart_DeletePersistentHandle or Dart_DeleteWeakPersistentHandle.\n This gives the embedder the ability to cleanup data associated with the\n object and clear out any cached references to the handle. All references to\n this handle after the callback will be invalid. It is illegal to call into\n the VM with any other Dart_* functions from the callback. If the handle is\n deleted before the object becomes unreachable, the callback is never\n invoked.\n\n Requires there to be a current isolate.\n\n \\param object An object with identity.\n \\param peer A pointer to a native object or NULL.  This value is\n   provided to callback when it is invoked.\n \\param external_allocation_size The number of externally allocated\n   bytes for peer. Used to inform the garbage collector.\n \\param callback A function pointer that will be invoked sometime\n   after the object is garbage collected, unless the handle has been deleted.\n   A valid callback needs to be specified it cannot be NULL.\n\n \\return The finalizable handle or NULL. NULL is returned in case of bad\n   parameters."]
    pub fn Dart_NewFinalizableHandle(
        object: Dart_Handle,
        peer: *mut ::std::os::raw::c_void,
        external_allocation_size: isize,
        callback: Dart_HandleFinalizer,
    ) -> Dart_FinalizableHandle;
}
unsafe extern "C" {
    #[doc = " Deletes the given finalizable [object] handle.\n\n The caller has to provide the actual Dart object the handle was created from\n to prove the object (and therefore the finalizable handle) is still alive.\n\n Requires there to be a current isolate."]
    pub fn Dart_DeleteFinalizableHandle(
        object: Dart_FinalizableHandle,
        strong_ref_to_object: Dart_Handle,
    );
}
unsafe extern "C" {
    #[doc = " Gets the version string for the Dart VM.\n\n The version of the Dart VM can be accessed without initializing the VM.\n\n \\return The version string for the embedded Dart VM."]
    pub fn Dart_VersionString() -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dart_IsolateFlags {
    pub version: i32,
    pub enable_asserts: bool,
    pub use_field_guards: bool,
    pub use_osr: bool,
    pub obfuscate: bool,
    pub load_vmservice_library: bool,
    pub null_safety: bool,
    pub is_system_isolate: bool,
    pub is_service_isolate: bool,
    pub is_kernel_isolate: bool,
    pub snapshot_is_dontneed_safe: bool,
    pub branch_coverage: bool,
    pub coverage: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Dart_IsolateFlags"][::std::mem::size_of::<Dart_IsolateFlags>() - 16usize];
    ["Alignment of Dart_IsolateFlags"][::std::mem::align_of::<Dart_IsolateFlags>() - 4usize];
    ["Offset of field: Dart_IsolateFlags::version"]
        [::std::mem::offset_of!(Dart_IsolateFlags, version) - 0usize];
    ["Offset of field: Dart_IsolateFlags::enable_asserts"]
        [::std::mem::offset_of!(Dart_IsolateFlags, enable_asserts) - 4usize];
    ["Offset of field: Dart_IsolateFlags::use_field_guards"]
        [::std::mem::offset_of!(Dart_IsolateFlags, use_field_guards) - 5usize];
    ["Offset of field: Dart_IsolateFlags::use_osr"]
        [::std::mem::offset_of!(Dart_IsolateFlags, use_osr) - 6usize];
    ["Offset of field: Dart_IsolateFlags::obfuscate"]
        [::std::mem::offset_of!(Dart_IsolateFlags, obfuscate) - 7usize];
    ["Offset of field: Dart_IsolateFlags::load_vmservice_library"]
        [::std::mem::offset_of!(Dart_IsolateFlags, load_vmservice_library) - 8usize];
    ["Offset of field: Dart_IsolateFlags::null_safety"]
        [::std::mem::offset_of!(Dart_IsolateFlags, null_safety) - 9usize];
    ["Offset of field: Dart_IsolateFlags::is_system_isolate"]
        [::std::mem::offset_of!(Dart_IsolateFlags, is_system_isolate) - 10usize];
    ["Offset of field: Dart_IsolateFlags::is_service_isolate"]
        [::std::mem::offset_of!(Dart_IsolateFlags, is_service_isolate) - 11usize];
    ["Offset of field: Dart_IsolateFlags::is_kernel_isolate"]
        [::std::mem::offset_of!(Dart_IsolateFlags, is_kernel_isolate) - 12usize];
    ["Offset of field: Dart_IsolateFlags::snapshot_is_dontneed_safe"]
        [::std::mem::offset_of!(Dart_IsolateFlags, snapshot_is_dontneed_safe) - 13usize];
    ["Offset of field: Dart_IsolateFlags::branch_coverage"]
        [::std::mem::offset_of!(Dart_IsolateFlags, branch_coverage) - 14usize];
    ["Offset of field: Dart_IsolateFlags::coverage"]
        [::std::mem::offset_of!(Dart_IsolateFlags, coverage) - 15usize];
};
unsafe extern "C" {
    #[doc = " Initialize Dart_IsolateFlags with correct version and default values."]
    pub fn Dart_IsolateFlagsInitialize(flags: *mut Dart_IsolateFlags);
}
#[doc = " An isolate creation and initialization callback function.\n\n This callback, provided by the embedder, is called when the VM\n needs to create an isolate. The callback should create an isolate\n by calling Dart_CreateIsolateGroup and load any scripts required for\n execution.\n\n This callback may be called on a different thread than the one\n running the parent isolate.\n\n When the function returns NULL, it is the responsibility of this\n function to ensure that Dart_ShutdownIsolate has been called if\n required (for example, if the isolate was created successfully by\n Dart_CreateIsolateGroup() but the root library fails to load\n successfully, then the function should call Dart_ShutdownIsolate\n before returning).\n\n When the function returns NULL, the function should set *error to\n a malloc-allocated buffer containing a useful error message.  The\n caller of this function (the VM) will make sure that the buffer is\n freed.\n\n \\param script_uri The uri of the main source file or snapshot to load.\n   Either the URI of the parent isolate set in Dart_CreateIsolateGroup for\n   Isolate.spawn, or the argument to Isolate.spawnUri canonicalized by the\n   library tag handler of the parent isolate.\n   The callback is responsible for loading the program by a call to\n   Dart_LoadScriptFromKernel.\n \\param main The name of the main entry point this isolate will\n   eventually run.  This is provided for advisory purposes only to\n   improve debugging messages.  The main function is not invoked by\n   this function.\n \\param package_root Ignored.\n \\param package_config Uri of the package configuration file (either in format\n   of .packages or .dart_tool/package_config.json) for this isolate\n   to resolve package imports against. If this parameter is not passed the\n   package resolution of the parent isolate should be used.\n \\param flags Default flags for this isolate being spawned. Either inherited\n   from the spawning isolate or passed as parameters when spawning the\n   isolate from Dart code.\n \\param isolate_data The isolate data which was passed to the\n   parent isolate when it was created by calling Dart_CreateIsolateGroup().\n \\param error A structure into which the embedder can place a\n   C string containing an error message in the case of failures.\n\n \\return The embedder returns NULL if the creation and\n   initialization was not successful and the isolate if successful."]
pub type Dart_IsolateGroupCreateCallback = ::std::option::Option<
    unsafe extern "C" fn(
        script_uri: *const ::std::os::raw::c_char,
        main: *const ::std::os::raw::c_char,
        package_root: *const ::std::os::raw::c_char,
        package_config: *const ::std::os::raw::c_char,
        flags: *mut Dart_IsolateFlags,
        isolate_data: *mut ::std::os::raw::c_void,
        error: *mut *mut ::std::os::raw::c_char,
    ) -> Dart_Isolate,
>;
#[doc = " An isolate initialization callback function.\n\n This callback, provided by the embedder, is called when the VM has created an\n isolate within an existing isolate group (i.e. from the same source as an\n existing isolate).\n\n The callback should setup native resolvers and might want to set a custom\n message handler via [Dart_SetMessageNotifyCallback] and mark the isolate as\n runnable.\n\n This callback may be called on a different thread than the one\n running the parent isolate.\n\n When the function returns `false`, it is the responsibility of this\n function to ensure that `Dart_ShutdownIsolate` has been called.\n\n When the function returns `false`, the function should set *error to\n a malloc-allocated buffer containing a useful error message.  The\n caller of this function (the VM) will make sure that the buffer is\n freed.\n\n \\param child_isolate_data The callback data to associate with the new\n        child isolate.\n \\param error A structure into which the embedder can place a\n   C string containing an error message in the case the initialization fails.\n\n \\return The embedder returns true if the initialization was successful and\n         false otherwise (in which case the VM will terminate the isolate)."]
pub type Dart_InitializeIsolateCallback = ::std::option::Option<
    unsafe extern "C" fn(
        child_isolate_data: *mut *mut ::std::os::raw::c_void,
        error: *mut *mut ::std::os::raw::c_char,
    ) -> bool,
>;
#[doc = " An isolate shutdown callback function.\n\n This callback, provided by the embedder, is called before the vm\n shuts down an isolate.  The isolate being shutdown will be the current\n isolate. It is safe to run Dart code.\n\n This function should be used to dispose of native resources that\n are allocated to an isolate in order to avoid leaks.\n\n \\param isolate_group_data The same callback data which was passed to the\n   isolate group when it was created.\n \\param isolate_data The same callback data which was passed to the isolate\n   when it was created."]
pub type Dart_IsolateShutdownCallback = ::std::option::Option<
    unsafe extern "C" fn(
        isolate_group_data: *mut ::std::os::raw::c_void,
        isolate_data: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " An isolate cleanup callback function.\n\n This callback, provided by the embedder, is called after the vm\n shuts down an isolate. There will be no current isolate and it is *not*\n safe to run Dart code.\n\n This function should be used to dispose of native resources that\n are allocated to an isolate in order to avoid leaks.\n\n \\param isolate_group_data The same callback data which was passed to the\n   isolate group when it was created.\n \\param isolate_data The same callback data which was passed to the isolate\n   when it was created."]
pub type Dart_IsolateCleanupCallback = ::std::option::Option<
    unsafe extern "C" fn(
        isolate_group_data: *mut ::std::os::raw::c_void,
        isolate_data: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " An isolate group cleanup callback function.\n\n This callback, provided by the embedder, is called after the vm\n shuts down an isolate group.\n\n This function should be used to dispose of native resources that\n are allocated to an isolate in order to avoid leaks.\n\n \\param isolate_group_data The same callback data which was passed to the\n   isolate group when it was created.\n"]
pub type Dart_IsolateGroupCleanupCallback =
    ::std::option::Option<unsafe extern "C" fn(isolate_group_data: *mut ::std::os::raw::c_void)>;
#[doc = " A thread start callback function.\n This callback, provided by the embedder, is called after a thread in the\n vm thread pool starts.\n This function could be used to adjust thread priority or attach native\n resources to the thread."]
pub type Dart_ThreadStartCallback = ::std::option::Option<unsafe extern "C" fn()>;
#[doc = " A thread death callback function.\n This callback, provided by the embedder, is called before a thread in the\n vm thread pool exits.\n This function could be used to dispose of native resources that\n are associated and attached to the thread, in order to avoid leaks."]
pub type Dart_ThreadExitCallback = ::std::option::Option<unsafe extern "C" fn()>;
#[doc = " Opens a file for reading or writing.\n\n Callback provided by the embedder for file operations. If the\n embedder does not allow file operations this callback can be\n NULL.\n\n \\param name The name of the file to open.\n \\param write A boolean variable which indicates if the file is to\n   opened for writing. If there is an existing file it needs to truncated."]
pub type Dart_FileOpenCallback = ::std::option::Option<
    unsafe extern "C" fn(
        name: *const ::std::os::raw::c_char,
        write: bool,
    ) -> *mut ::std::os::raw::c_void,
>;
#[doc = " Read contents of file.\n\n Callback provided by the embedder for file operations. If the\n embedder does not allow file operations this callback can be\n NULL.\n\n \\param data Buffer allocated in the callback into which the contents\n   of the file are read into. It is the responsibility of the caller to\n   free this buffer.\n \\param file_length A variable into which the length of the file is returned.\n   In the case of an error this value would be -1.\n \\param stream Handle to the opened file."]
pub type Dart_FileReadCallback = ::std::option::Option<
    unsafe extern "C" fn(
        data: *mut *mut u8,
        file_length: *mut isize,
        stream: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " Write data into file.\n\n Callback provided by the embedder for file operations. If the\n embedder does not allow file operations this callback can be\n NULL.\n\n \\param data Buffer which needs to be written into the file.\n \\param length Length of the buffer.\n \\param stream Handle to the opened file."]
pub type Dart_FileWriteCallback = ::std::option::Option<
    unsafe extern "C" fn(
        data: *const ::std::os::raw::c_void,
        length: isize,
        stream: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " Closes the opened file.\n\n Callback provided by the embedder for file operations. If the\n embedder does not allow file operations this callback can be\n NULL.\n\n \\param stream Handle to the opened file."]
pub type Dart_FileCloseCallback =
    ::std::option::Option<unsafe extern "C" fn(stream: *mut ::std::os::raw::c_void)>;
pub type Dart_EntropySource =
    ::std::option::Option<unsafe extern "C" fn(buffer: *mut u8, length: isize) -> bool>;
#[doc = " Callback provided by the embedder that is used by the vmservice isolate\n to request the asset archive. The asset archive must be an uncompressed tar\n archive that is stored in a Uint8List.\n\n If the embedder has no vmservice isolate assets, the callback can be NULL.\n\n \\return The embedder must return a handle to a Uint8List containing an\n   uncompressed tar archive or null."]
pub type Dart_GetVMServiceAssetsArchive =
    ::std::option::Option<unsafe extern "C" fn() -> Dart_Handle>;
#[doc = " Callback provided by the embedder that is used by the VM to notify on code\n object creation, *before* it is invoked the first time.\n This is useful for embedders wanting to e.g. keep track of PCs beyond\n the lifetime of the garbage collected code objects.\n Note that an address range may be used by more than one code object over the\n lifecycle of a process. Clients of this function should record timestamps for\n these compilation events and when collecting PCs to disambiguate reused\n address ranges."]
pub type Dart_OnNewCodeCallback = ::std::option::Option<
    unsafe extern "C" fn(
        observer: *mut Dart_CodeObserver,
        name: *const ::std::os::raw::c_char,
        base: usize,
        size: usize,
    ),
>;
#[doc = " Forward declaration"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dart_CodeObserver {
    pub data: *mut ::std::os::raw::c_void,
    pub on_new_code: Dart_OnNewCodeCallback,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Dart_CodeObserver"][::std::mem::size_of::<Dart_CodeObserver>() - 16usize];
    ["Alignment of Dart_CodeObserver"][::std::mem::align_of::<Dart_CodeObserver>() - 8usize];
    ["Offset of field: Dart_CodeObserver::data"]
        [::std::mem::offset_of!(Dart_CodeObserver, data) - 0usize];
    ["Offset of field: Dart_CodeObserver::on_new_code"]
        [::std::mem::offset_of!(Dart_CodeObserver, on_new_code) - 8usize];
};
#[doc = " Describes how to initialize the VM. Used with Dart_Initialize."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dart_InitializeParams {
    #[doc = " Identifies the version of the struct used by the client.\n should be initialized to DART_INITIALIZE_PARAMS_CURRENT_VERSION."]
    pub version: i32,
    #[doc = " A buffer containing snapshot data, or NULL if no snapshot is provided.\n\n If provided, the buffer must remain valid until Dart_Cleanup returns."]
    pub vm_snapshot_data: *const u8,
    #[doc = " A buffer containing a snapshot of precompiled instructions, or NULL if\n no snapshot is provided.\n\n If provided, the buffer must remain valid until Dart_Cleanup returns."]
    pub vm_snapshot_instructions: *const u8,
    #[doc = " A function to be called during isolate group creation.\n See Dart_IsolateGroupCreateCallback."]
    pub create_group: Dart_IsolateGroupCreateCallback,
    #[doc = " A function to be called during isolate\n initialization inside an existing isolate group.\n See Dart_InitializeIsolateCallback."]
    pub initialize_isolate: Dart_InitializeIsolateCallback,
    #[doc = " A function to be called right before an isolate is shutdown.\n See Dart_IsolateShutdownCallback."]
    pub shutdown_isolate: Dart_IsolateShutdownCallback,
    #[doc = " A function to be called after an isolate was shutdown.\n See Dart_IsolateCleanupCallback."]
    pub cleanup_isolate: Dart_IsolateCleanupCallback,
    #[doc = " A function to be called after an isolate group is\n shutdown. See Dart_IsolateGroupCleanupCallback."]
    pub cleanup_group: Dart_IsolateGroupCleanupCallback,
    pub thread_start: Dart_ThreadStartCallback,
    pub thread_exit: Dart_ThreadExitCallback,
    pub file_open: Dart_FileOpenCallback,
    pub file_read: Dart_FileReadCallback,
    pub file_write: Dart_FileWriteCallback,
    pub file_close: Dart_FileCloseCallback,
    pub entropy_source: Dart_EntropySource,
    #[doc = " A function to be called by the service isolate when it requires the\n vmservice assets archive. See Dart_GetVMServiceAssetsArchive."]
    pub get_service_assets: Dart_GetVMServiceAssetsArchive,
    pub start_kernel_isolate: bool,
    #[doc = " An external code observer callback function. The observer can be invoked\n as early as during the Dart_Initialize() call."]
    pub code_observer: *mut Dart_CodeObserver,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Dart_InitializeParams"][::std::mem::size_of::<Dart_InitializeParams>() - 144usize];
    ["Alignment of Dart_InitializeParams"]
        [::std::mem::align_of::<Dart_InitializeParams>() - 8usize];
    ["Offset of field: Dart_InitializeParams::version"]
        [::std::mem::offset_of!(Dart_InitializeParams, version) - 0usize];
    ["Offset of field: Dart_InitializeParams::vm_snapshot_data"]
        [::std::mem::offset_of!(Dart_InitializeParams, vm_snapshot_data) - 8usize];
    ["Offset of field: Dart_InitializeParams::vm_snapshot_instructions"]
        [::std::mem::offset_of!(Dart_InitializeParams, vm_snapshot_instructions) - 16usize];
    ["Offset of field: Dart_InitializeParams::create_group"]
        [::std::mem::offset_of!(Dart_InitializeParams, create_group) - 24usize];
    ["Offset of field: Dart_InitializeParams::initialize_isolate"]
        [::std::mem::offset_of!(Dart_InitializeParams, initialize_isolate) - 32usize];
    ["Offset of field: Dart_InitializeParams::shutdown_isolate"]
        [::std::mem::offset_of!(Dart_InitializeParams, shutdown_isolate) - 40usize];
    ["Offset of field: Dart_InitializeParams::cleanup_isolate"]
        [::std::mem::offset_of!(Dart_InitializeParams, cleanup_isolate) - 48usize];
    ["Offset of field: Dart_InitializeParams::cleanup_group"]
        [::std::mem::offset_of!(Dart_InitializeParams, cleanup_group) - 56usize];
    ["Offset of field: Dart_InitializeParams::thread_start"]
        [::std::mem::offset_of!(Dart_InitializeParams, thread_start) - 64usize];
    ["Offset of field: Dart_InitializeParams::thread_exit"]
        [::std::mem::offset_of!(Dart_InitializeParams, thread_exit) - 72usize];
    ["Offset of field: Dart_InitializeParams::file_open"]
        [::std::mem::offset_of!(Dart_InitializeParams, file_open) - 80usize];
    ["Offset of field: Dart_InitializeParams::file_read"]
        [::std::mem::offset_of!(Dart_InitializeParams, file_read) - 88usize];
    ["Offset of field: Dart_InitializeParams::file_write"]
        [::std::mem::offset_of!(Dart_InitializeParams, file_write) - 96usize];
    ["Offset of field: Dart_InitializeParams::file_close"]
        [::std::mem::offset_of!(Dart_InitializeParams, file_close) - 104usize];
    ["Offset of field: Dart_InitializeParams::entropy_source"]
        [::std::mem::offset_of!(Dart_InitializeParams, entropy_source) - 112usize];
    ["Offset of field: Dart_InitializeParams::get_service_assets"]
        [::std::mem::offset_of!(Dart_InitializeParams, get_service_assets) - 120usize];
    ["Offset of field: Dart_InitializeParams::start_kernel_isolate"]
        [::std::mem::offset_of!(Dart_InitializeParams, start_kernel_isolate) - 128usize];
    ["Offset of field: Dart_InitializeParams::code_observer"]
        [::std::mem::offset_of!(Dart_InitializeParams, code_observer) - 136usize];
};
unsafe extern "C" {
    #[doc = " Initializes the VM.\n\n \\param params A struct containing initialization information. The version\n   field of the struct must be DART_INITIALIZE_PARAMS_CURRENT_VERSION.\n\n \\return NULL if initialization is successful. Returns an error message\n   otherwise. The caller is responsible for freeing the error message."]
    pub fn Dart_Initialize(params: *mut Dart_InitializeParams) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Cleanup state in the VM before process termination.\n\n \\return NULL if cleanup is successful. Returns an error message otherwise.\n   The caller is responsible for freeing the error message.\n\n NOTE: This function must not be called on a thread that was created by the VM\n itself."]
    pub fn Dart_Cleanup() -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Sets command line flags. Should be called before Dart_Initialize.\n\n \\param argc The length of the arguments array.\n \\param argv An array of arguments.\n\n \\return NULL if successful. Returns an error message otherwise.\n  The caller is responsible for freeing the error message.\n\n NOTE: This call does not store references to the passed in c-strings."]
    pub fn Dart_SetVMFlags(
        argc: ::std::os::raw::c_int,
        argv: *mut *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Returns true if the named VM flag is of boolean type, specified, and set to\n true.\n\n \\param flag_name The name of the flag without leading punctuation\n                  (example: \"enable_asserts\")."]
    pub fn Dart_IsVMFlagSet(flag_name: *const ::std::os::raw::c_char) -> bool;
}
unsafe extern "C" {
    #[doc = " Creates a new isolate. The new isolate becomes the current isolate.\n\n A snapshot can be used to restore the VM quickly to a saved state\n and is useful for fast startup. If snapshot data is provided, the\n isolate will be started using that snapshot data. Requires a core snapshot or\n an app snapshot created by Dart_CreateSnapshot or\n Dart_CreatePrecompiledSnapshot* from a VM with the same version.\n\n Requires there to be no current isolate.\n\n \\param script_uri The main source file or snapshot this isolate will load.\n   The VM will provide this URI to the Dart_IsolateGroupCreateCallback when a\n   child isolate is created by Isolate.spawn. The embedder should use a URI\n   that allows it to load the same program into such a child isolate.\n \\param name A short name for the isolate to improve debugging messages.\n   Typically of the format 'foo.dart:main()'.\n \\param isolate_snapshot_data Buffer containing the snapshot data of the\n   isolate or NULL if no snapshot is provided. If provided, the buffer must\n   remain valid until the isolate shuts down.\n \\param isolate_snapshot_instructions Buffer containing the snapshot\n   instructions of the isolate or NULL if no snapshot is provided. If\n   provided, the buffer must remain valid until the isolate shuts down.\n \\param flags Pointer to VM specific flags or NULL for default flags.\n \\param isolate_group_data Embedder group data. This data can be obtained\n   by calling Dart_IsolateGroupData and will be passed to the\n   Dart_IsolateShutdownCallback, Dart_IsolateCleanupCallback, and\n   Dart_IsolateGroupCleanupCallback.\n \\param isolate_data Embedder data.  This data will be passed to\n   the Dart_IsolateGroupCreateCallback when new isolates are spawned from\n   this parent isolate.\n \\param error Returns NULL if creation is successful, an error message\n   otherwise. The caller is responsible for calling free() on the error\n   message.\n\n \\return The new isolate on success, or NULL if isolate creation failed."]
    pub fn Dart_CreateIsolateGroup(
        script_uri: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        isolate_snapshot_data: *const u8,
        isolate_snapshot_instructions: *const u8,
        flags: *mut Dart_IsolateFlags,
        isolate_group_data: *mut ::std::os::raw::c_void,
        isolate_data: *mut ::std::os::raw::c_void,
        error: *mut *mut ::std::os::raw::c_char,
    ) -> Dart_Isolate;
}
unsafe extern "C" {
    #[doc = " Creates a new isolate inside the isolate group of [group_member].\n\n Requires there to be no current isolate.\n\n \\param group_member An isolate from the same group into which the newly created\n   isolate should be born into. Other threads may not have entered / enter this\n   member isolate.\n \\param name A short name for the isolate for debugging purposes.\n \\param shutdown_callback A callback to be called when the isolate is being\n   shutdown (may be NULL).\n \\param cleanup_callback A callback to be called when the isolate is being\n   cleaned up (may be NULL).\n \\param child_isolate_data The embedder-specific data associated with this isolate.\n \\param error Set to NULL if creation is successful, set to an error\n   message otherwise. The caller is responsible for calling free() on the\n   error message.\n\n \\return The newly created isolate on success, or NULL if isolate creation\n   failed.\n\n If successful, the newly created isolate will become the current isolate."]
    pub fn Dart_CreateIsolateInGroup(
        group_member: Dart_Isolate,
        name: *const ::std::os::raw::c_char,
        shutdown_callback: Dart_IsolateShutdownCallback,
        cleanup_callback: Dart_IsolateCleanupCallback,
        child_isolate_data: *mut ::std::os::raw::c_void,
        error: *mut *mut ::std::os::raw::c_char,
    ) -> Dart_Isolate;
}
unsafe extern "C" {
    #[doc = " Creates a new isolate from a Dart Kernel file. The new isolate\n becomes the current isolate.\n\n Requires there to be no current isolate.\n\n \\param script_uri The main source file or snapshot this isolate will load.\n   The VM will provide this URI to the Dart_IsolateGroupCreateCallback when a\n child isolate is created by Isolate.spawn. The embedder should use a URI that\n   allows it to load the same program into such a child isolate.\n \\param name A short name for the isolate to improve debugging messages.\n   Typically of the format 'foo.dart:main()'.\n \\param kernel_buffer A buffer which contains a kernel/DIL program. Must\n   remain valid until isolate shutdown.\n \\param kernel_buffer_size The size of `kernel_buffer`.\n \\param flags Pointer to VM specific flags or NULL for default flags.\n \\param isolate_group_data Embedder group data. This data can be obtained\n   by calling Dart_IsolateGroupData and will be passed to the\n   Dart_IsolateShutdownCallback, Dart_IsolateCleanupCallback, and\n   Dart_IsolateGroupCleanupCallback.\n \\param isolate_data Embedder data.  This data will be passed to\n   the Dart_IsolateGroupCreateCallback when new isolates are spawned from\n   this parent isolate.\n \\param error Returns NULL if creation is successful, an error message\n   otherwise. The caller is responsible for calling free() on the error\n   message.\n\n \\return The new isolate on success, or NULL if isolate creation failed."]
    pub fn Dart_CreateIsolateGroupFromKernel(
        script_uri: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        kernel_buffer: *const u8,
        kernel_buffer_size: isize,
        flags: *mut Dart_IsolateFlags,
        isolate_group_data: *mut ::std::os::raw::c_void,
        isolate_data: *mut ::std::os::raw::c_void,
        error: *mut *mut ::std::os::raw::c_char,
    ) -> Dart_Isolate;
}
unsafe extern "C" {
    #[doc = " Shuts down the current isolate. After this call, the current isolate is NULL.\n Any current scopes created by Dart_EnterScope will be exited. Invokes the\n shutdown callback and any callbacks of remaining weak persistent handles.\n\n Requires there to be a current isolate."]
    pub fn Dart_ShutdownIsolate();
}
unsafe extern "C" {
    #[doc = " Returns the current isolate. Will return NULL if there is no\n current isolate."]
    pub fn Dart_CurrentIsolate() -> Dart_Isolate;
}
unsafe extern "C" {
    #[doc = " Returns the callback data associated with the current isolate. This\n data was set when the isolate got created or initialized."]
    pub fn Dart_CurrentIsolateData() -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " Returns the callback data associated with the given isolate. This\n data was set when the isolate got created or initialized."]
    pub fn Dart_IsolateData(isolate: Dart_Isolate) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " Returns the current isolate group. Will return NULL if there is no\n current isolate group."]
    pub fn Dart_CurrentIsolateGroup() -> Dart_IsolateGroup;
}
unsafe extern "C" {
    #[doc = " Returns the callback data associated with the current isolate group. This\n data was passed to the isolate group when it was created."]
    pub fn Dart_CurrentIsolateGroupData() -> *mut ::std::os::raw::c_void;
}
#[doc = " Gets an id that uniquely identifies current isolate group.\n\n It is the responsibility of the caller to free the returned ID."]
pub type Dart_IsolateGroupId = i64;
unsafe extern "C" {
    pub fn Dart_CurrentIsolateGroupId() -> Dart_IsolateGroupId;
}
unsafe extern "C" {
    #[doc = " Returns the callback data associated with the specified isolate group. This\n data was passed to the isolate when it was created.\n The embedder is responsible for ensuring the consistency of this data\n with respect to the lifecycle of an isolate group."]
    pub fn Dart_IsolateGroupData(isolate: Dart_Isolate) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " Returns the debugging name for the current isolate.\n\n This name is unique to each isolate and should only be used to make\n debugging messages more comprehensible."]
    pub fn Dart_DebugName() -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Returns the debugging name for the current isolate.\n\n This name is unique to each isolate and should only be used to make\n debugging messages more comprehensible.\n\n The returned string is scope allocated and is only valid until the next call\n to Dart_ExitScope."]
    pub fn Dart_DebugNameToCString() -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Returns the ID for an isolate which is used to query the service protocol.\n\n It is the responsibility of the caller to free the returned ID."]
    pub fn Dart_IsolateServiceId(isolate: Dart_Isolate) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Enters an isolate. After calling this function,\n the current isolate will be set to the provided isolate.\n\n Requires there to be no current isolate. Multiple threads may not be in\n the same isolate at once."]
    pub fn Dart_EnterIsolate(isolate: Dart_Isolate);
}
unsafe extern "C" {
    #[doc = " Kills the given isolate.\n\n This function has the same effect as dart:isolate's\n Isolate.kill(priority:immediate).\n It can interrupt ordinary Dart code but not native code. If the isolate is\n in the middle of a long running native function, the isolate will not be\n killed until control returns to Dart.\n\n Does not require a current isolate. It is safe to kill the current isolate if\n there is one."]
    pub fn Dart_KillIsolate(isolate: Dart_Isolate);
}
unsafe extern "C" {
    #[doc = " Notifies the VM that the embedder expects to be idle until |deadline|. The VM\n may use this time to perform garbage collection or other tasks to avoid\n delays during execution of Dart code in the future.\n\n |deadline| is measured in microseconds against the system's monotonic time.\n This clock can be accessed via Dart_TimelineGetMicros().\n\n Requires there to be a current isolate."]
    pub fn Dart_NotifyIdle(deadline: i64);
}
pub type Dart_HeapSamplingReportCallback = ::std::option::Option<
    unsafe extern "C" fn(context: *mut ::std::os::raw::c_void, data: *mut ::std::os::raw::c_void),
>;
pub type Dart_HeapSamplingCreateCallback = ::std::option::Option<
    unsafe extern "C" fn(
        isolate: Dart_Isolate,
        isolate_group: Dart_IsolateGroup,
        cls_name: *const ::std::os::raw::c_char,
        allocation_size: isize,
    ) -> *mut ::std::os::raw::c_void,
>;
pub type Dart_HeapSamplingDeleteCallback =
    ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>;
unsafe extern "C" {
    #[doc = " Starts the heap sampling profiler for each thread in the VM."]
    pub fn Dart_EnableHeapSampling();
}
unsafe extern "C" {
    pub fn Dart_DisableHeapSampling();
}
unsafe extern "C" {
    pub fn Dart_RegisterHeapSamplingCallback(
        create_callback: Dart_HeapSamplingCreateCallback,
        delete_callback: Dart_HeapSamplingDeleteCallback,
    );
}
unsafe extern "C" {
    pub fn Dart_ReportSurvivingAllocations(
        callback: Dart_HeapSamplingReportCallback,
        context: *mut ::std::os::raw::c_void,
        force_gc: bool,
    );
}
unsafe extern "C" {
    pub fn Dart_SetHeapSamplingPeriod(bytes: isize);
}
unsafe extern "C" {
    #[doc = " Notifies the VM that the embedder expects the application's working set has\n recently shrunk significantly and is not expected to rise in the near future.\n The VM may spend O(heap-size) time performing clean up work.\n\n Requires there to be a current isolate."]
    pub fn Dart_NotifyDestroyed();
}
unsafe extern "C" {
    #[doc = " Notifies the VM that the system is running low on memory.\n\n Does not require a current isolate. Only valid after calling Dart_Initialize."]
    pub fn Dart_NotifyLowMemory();
}
#[doc = " Balanced"]
pub const Dart_PerformanceMode_Dart_PerformanceMode_Default: Dart_PerformanceMode = 0;
#[doc = " Optimize for low latency, at the expense of throughput and memory overhead\n by performing work in smaller batches (requiring more overhead) or by\n delaying work (requiring more memory). An embedder should not remain in\n this mode indefinitely."]
pub const Dart_PerformanceMode_Dart_PerformanceMode_Latency: Dart_PerformanceMode = 1;
#[doc = " Optimize for high throughput, at the expense of latency and memory overhead\n by performing work in larger batches with more intervening growth."]
pub const Dart_PerformanceMode_Dart_PerformanceMode_Throughput: Dart_PerformanceMode = 2;
#[doc = " Optimize for low memory, at the expensive of throughput and latency by more\n frequently performing work."]
pub const Dart_PerformanceMode_Dart_PerformanceMode_Memory: Dart_PerformanceMode = 3;
pub type Dart_PerformanceMode = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " Set the desired performance trade-off.\n\n Requires a current isolate.\n\n Returns the previous performance mode."]
    pub fn Dart_SetPerformanceMode(mode: Dart_PerformanceMode) -> Dart_PerformanceMode;
}
unsafe extern "C" {
    #[doc = " Starts the CPU sampling profiler."]
    pub fn Dart_StartProfiling();
}
unsafe extern "C" {
    #[doc = " Stops the CPU sampling profiler.\n\n Note that some profile samples might still be taken after this function\n returns due to the asynchronous nature of the implementation on some\n platforms."]
    pub fn Dart_StopProfiling();
}
unsafe extern "C" {
    #[doc = " Notifies the VM that the current thread should not be profiled until a\n matching call to Dart_ThreadEnableProfiling is made.\n\n NOTE: By default, if a thread has entered an isolate it will be profiled.\n This function should be used when an embedder knows a thread is about\n to make a blocking call and wants to avoid unnecessary interrupts by\n the profiler."]
    pub fn Dart_ThreadDisableProfiling();
}
unsafe extern "C" {
    #[doc = " Notifies the VM that the current thread should be profiled.\n\n NOTE: It is only legal to call this function *after* calling\n   Dart_ThreadDisableProfiling.\n\n NOTE: By default, if a thread has entered an isolate it will be profiled."]
    pub fn Dart_ThreadEnableProfiling();
}
unsafe extern "C" {
    #[doc = " Register symbol information for the Dart VM's profiler and crash dumps.\n\n This consumes the output of //topaz/runtime/dart/profiler_symbols, which\n should be treated as opaque."]
    pub fn Dart_AddSymbols(
        dso_name: *const ::std::os::raw::c_char,
        buffer: *mut ::std::os::raw::c_void,
        buffer_size: isize,
    );
}
unsafe extern "C" {
    #[doc = " Exits an isolate. After this call, Dart_CurrentIsolate will\n return NULL.\n\n Requires there to be a current isolate."]
    pub fn Dart_ExitIsolate();
}
unsafe extern "C" {
    #[doc = " Creates a full snapshot of the current isolate heap.\n\n A full snapshot is a compact representation of the dart vm isolate heap\n and dart isolate heap states. These snapshots are used to initialize\n the vm isolate on startup and fast initialization of an isolate.\n A Snapshot of the heap is created before any dart code has executed.\n\n Requires there to be a current isolate. Not available in the precompiled\n runtime (check Dart_IsPrecompiledRuntime).\n\n \\param vm_snapshot_data_buffer Returns a pointer to a buffer containing the\n   vm snapshot. This buffer is scope allocated and is only valid\n   until the next call to Dart_ExitScope.\n \\param vm_snapshot_data_size Returns the size of vm_snapshot_data_buffer.\n \\param isolate_snapshot_data_buffer Returns a pointer to a buffer containing\n   the isolate snapshot. This buffer is scope allocated and is only valid\n   until the next call to Dart_ExitScope.\n \\param isolate_snapshot_data_size Returns the size of\n   isolate_snapshot_data_buffer.\n \\param is_core Create a snapshot containing core libraries.\n   Such snapshot should be agnostic to null safety mode.\n\n \\return A valid handle if no error occurs during the operation."]
    pub fn Dart_CreateSnapshot(
        vm_snapshot_data_buffer: *mut *mut u8,
        vm_snapshot_data_size: *mut isize,
        isolate_snapshot_data_buffer: *mut *mut u8,
        isolate_snapshot_data_size: *mut isize,
        is_core: bool,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Returns whether the buffer contains a kernel file.\n\n \\param buffer Pointer to a buffer that might contain a kernel binary.\n \\param buffer_size Size of the buffer.\n\n \\return Whether the buffer contains a kernel binary (full or partial)."]
    pub fn Dart_IsKernel(buffer: *const u8, buffer_size: isize) -> bool;
}
unsafe extern "C" {
    #[doc = " Make isolate runnable.\n\n When isolates are spawned, this function is used to indicate that\n the creation and initialization (including script loading) of the\n isolate is complete and the isolate can start.\n This function expects there to be no current isolate.\n\n \\param isolate The isolate to be made runnable.\n\n \\return NULL if successful. Returns an error message otherwise. The caller\n is responsible for freeing the error message."]
    pub fn Dart_IsolateMakeRunnable(isolate: Dart_Isolate) -> *mut ::std::os::raw::c_char;
}
#[doc = " A port is used to send or receive inter-isolate messages"]
pub type Dart_Port = i64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dart_PortEx {
    pub port_id: i64,
    pub origin_id: i64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Dart_PortEx"][::std::mem::size_of::<Dart_PortEx>() - 16usize];
    ["Alignment of Dart_PortEx"][::std::mem::align_of::<Dart_PortEx>() - 8usize];
    ["Offset of field: Dart_PortEx::port_id"]
        [::std::mem::offset_of!(Dart_PortEx, port_id) - 0usize];
    ["Offset of field: Dart_PortEx::origin_id"]
        [::std::mem::offset_of!(Dart_PortEx, origin_id) - 8usize];
};
#[doc = " A message notification callback.\n\n This callback allows the embedder to provide a custom wakeup mechanism for\n the delivery of inter-isolate messages. This function is called once per\n message on an arbitrary thread. It is the responsibility of the embedder to\n eventually call Dart_HandleMessage once per callback received with the\n destination isolate set as the current isolate to process the message."]
pub type Dart_MessageNotifyCallback =
    ::std::option::Option<unsafe extern "C" fn(destination_isolate: Dart_Isolate)>;
unsafe extern "C" {
    #[doc = " Allows embedders to provide a custom wakeup mechanism for the delivery of\n inter-isolate messages. This setting only applies to the current isolate.\n\n This mechanism is optional: if not provided, the isolate will be scheduled on\n a VM-managed thread pool. An embedder should provide this callback if it\n wants to run an isolate on a specific thread or to interleave handling of\n inter-isolate messages with other event sources.\n\n Most embedders will only call this function once, before isolate\n execution begins. If this function is called after isolate\n execution begins, the embedder is responsible for threading issues."]
    pub fn Dart_SetMessageNotifyCallback(message_notify_callback: Dart_MessageNotifyCallback);
}
unsafe extern "C" {
    #[doc = " Query the current message notify callback for the isolate.\n\n \\return The current message notify callback for the isolate."]
    pub fn Dart_GetMessageNotifyCallback() -> Dart_MessageNotifyCallback;
}
unsafe extern "C" {
    #[doc = " If the VM flag `--pause-isolates-on-start` was passed this will be true.\n\n \\return A boolean value indicating if pause on start was requested."]
    pub fn Dart_ShouldPauseOnStart() -> bool;
}
unsafe extern "C" {
    #[doc = " Override the VM flag `--pause-isolates-on-start` for the current isolate.\n\n \\param should_pause Should the isolate be paused on start?\n\n NOTE: This must be called before Dart_IsolateMakeRunnable."]
    pub fn Dart_SetShouldPauseOnStart(should_pause: bool);
}
unsafe extern "C" {
    #[doc = " Is the current isolate paused on start?\n\n \\return A boolean value indicating if the isolate is paused on start."]
    pub fn Dart_IsPausedOnStart() -> bool;
}
unsafe extern "C" {
    #[doc = " Called when the embedder has paused the current isolate on start and when\n the embedder has resumed the isolate.\n\n \\param paused Is the isolate paused on start?"]
    pub fn Dart_SetPausedOnStart(paused: bool);
}
unsafe extern "C" {
    #[doc = " If the VM flag `--pause-isolates-on-exit` was passed this will be true.\n\n \\return A boolean value indicating if pause on exit was requested."]
    pub fn Dart_ShouldPauseOnExit() -> bool;
}
unsafe extern "C" {
    #[doc = " Override the VM flag `--pause-isolates-on-exit` for the current isolate.\n\n \\param should_pause Should the isolate be paused on exit?\n"]
    pub fn Dart_SetShouldPauseOnExit(should_pause: bool);
}
unsafe extern "C" {
    #[doc = " Is the current isolate paused on exit?\n\n \\return A boolean value indicating if the isolate is paused on exit."]
    pub fn Dart_IsPausedOnExit() -> bool;
}
unsafe extern "C" {
    #[doc = " Called when the embedder has paused the current isolate on exit and when\n the embedder has resumed the isolate.\n\n \\param paused Is the isolate paused on exit?"]
    pub fn Dart_SetPausedOnExit(paused: bool);
}
unsafe extern "C" {
    #[doc = " Called when the embedder has caught a top level unhandled exception error\n in the current isolate.\n\n NOTE: It is illegal to call this twice on the same isolate without first\n clearing the sticky error to null.\n\n \\param error The unhandled exception error."]
    pub fn Dart_SetStickyError(error: Dart_Handle);
}
unsafe extern "C" {
    #[doc = " Does the current isolate have a sticky error?"]
    pub fn Dart_HasStickyError() -> bool;
}
unsafe extern "C" {
    #[doc = " Gets the sticky error for the current isolate.\n\n \\return A handle to the sticky error object or null."]
    pub fn Dart_GetStickyError() -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Handles the next pending message for the current isolate.\n\n May generate an unhandled exception error.\n\n \\return A valid handle if no error occurs during the operation."]
    pub fn Dart_HandleMessage() -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Handles any pending messages for the vm service for the current\n isolate.\n\n This function may be used by an embedder at a breakpoint to avoid\n pausing the vm service.\n\n This function can indirectly cause the message notify callback to\n be called.\n\n \\return true if the vm service requests the program resume\n execution, false otherwise"]
    pub fn Dart_HandleServiceMessages() -> bool;
}
unsafe extern "C" {
    #[doc = " Does the current isolate have pending service messages?\n\n \\return true if the isolate has pending service messages, false otherwise."]
    pub fn Dart_HasServiceMessages() -> bool;
}
unsafe extern "C" {
    #[doc = " Processes any incoming messages for the current isolate.\n\n This function may only be used when the embedder has not provided\n an alternate message delivery mechanism with\n Dart_SetMessageCallbacks. It is provided for convenience.\n\n This function waits for incoming messages for the current\n isolate. As new messages arrive, they are handled using\n Dart_HandleMessage. The routine exits when all ports to the\n current isolate are closed.\n\n \\return A valid handle if the run loop exited successfully.  If an\n   exception or other error occurs while processing messages, an\n   error handle is returned."]
    pub fn Dart_RunLoop() -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Lets the VM run message processing for the isolate.\n\n This function expects there to a current isolate and the current isolate\n must not have an active api scope. The VM will take care of making the\n isolate runnable (if not already), handles its message loop and will take\n care of shutting the isolate down once it's done.\n\n \\param errors_are_fatal Whether uncaught errors should be fatal.\n \\param on_error_port A port to notify on uncaught errors (or ILLEGAL_PORT).\n \\param on_exit_port A port to notify on exit (or ILLEGAL_PORT).\n \\param error A non-NULL pointer which will hold an error message if the call\n   fails. The error has to be free()ed by the caller.\n\n \\return If successful the VM takes ownership of the isolate and takes care\n   of its message loop. If not successful the caller retains ownership of the\n   isolate."]
    pub fn Dart_RunLoopAsync(
        errors_are_fatal: bool,
        on_error_port: Dart_Port,
        on_exit_port: Dart_Port,
        error: *mut *mut ::std::os::raw::c_char,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Gets the main port id for the current isolate."]
    pub fn Dart_GetMainPortId() -> Dart_Port;
}
unsafe extern "C" {
    #[doc = " Does the current isolate have live ReceivePorts?\n\n A ReceivePort is live when it has not been closed."]
    pub fn Dart_HasLivePorts() -> bool;
}
unsafe extern "C" {
    #[doc = " Posts a message for some isolate. The message is a serialized\n object.\n\n Requires there to be a current isolate.\n\n For posting messages outside of an isolate see \\ref Dart_PostCObject.\n\n \\param port_id The destination port.\n \\param object An object from the current isolate.\n\n \\return True if the message was posted."]
    pub fn Dart_Post(port_id: Dart_Port, object: Dart_Handle) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns a new SendPort with the provided port id.\n\n If there is a possibility of a port closing since port_id was acquired\n for a SendPort, one should use Dart_NewSendPortEx and\n Dart_SendPortGetIdEx.\n\n \\param port_id The destination port.\n\n \\return A new SendPort if no errors occurs. Otherwise returns\n   an error handle."]
    pub fn Dart_NewSendPort(port_id: Dart_Port) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Returns a new SendPort with the provided port id and origin id.\n\n \\param portex_id The destination composte port id.\n\n \\return A new SendPort if no errors occurs. Otherwise returns\n   an error handle."]
    pub fn Dart_NewSendPortEx(portex_id: Dart_PortEx) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Gets the SendPort id for the provided SendPort.\n \\param port A SendPort object whose id is desired.\n \\param port_id Returns the id of the SendPort.\n \\return Success if no error occurs. Otherwise returns\n   an error handle."]
    pub fn Dart_SendPortGetId(port: Dart_Handle, port_id: *mut Dart_Port) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Gets the SendPort and Origin ids for the provided SendPort.\n \\param port A SendPort object whose id is desired.\n \\param portex_id Returns composite id of the SendPort.\n \\return Success if no error occurs. Otherwise returns\n   an error handle."]
    pub fn Dart_SendPortGetIdEx(port: Dart_Handle, portex_id: *mut Dart_PortEx) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Sets the owner thread of the current isolate to be the current thread.\n\n Requires there to be a current isolate, and that the isolate is unowned."]
    pub fn Dart_SetCurrentThreadOwnsIsolate();
}
unsafe extern "C" {
    #[doc = " Returns whether the current thread owns the isolate that owns the given port.\n\n The port can be the isolate's main port, or any other port owned by the\n isolate.\n\n \\param port_id The port to be checked."]
    pub fn Dart_GetCurrentThreadOwnsIsolate(port: Dart_Port) -> bool;
}
unsafe extern "C" {
    #[doc = " Enters a new scope.\n\n All new local handles will be created in this scope. Additionally,\n some functions may return \"scope allocated\" memory which is only\n valid within this scope.\n\n Requires there to be a current isolate."]
    pub fn Dart_EnterScope();
}
unsafe extern "C" {
    #[doc = " Exits a scope.\n\n The previous scope (if any) becomes the current scope.\n\n Requires there to be a current isolate."]
    pub fn Dart_ExitScope();
}
unsafe extern "C" {
    #[doc = " The Dart VM uses \"zone allocation\" for temporary structures. Zones\n support very fast allocation of small chunks of memory. The chunks\n cannot be deallocated individually, but instead zones support\n deallocating all chunks in one fast operation.\n\n This function makes it possible for the embedder to allocate\n temporary data in the VMs zone allocator.\n\n Zone allocation is possible:\n   1. when inside a scope where local handles can be allocated\n   2. when processing a message from a native port in a native port\n      handler\n\n All the memory allocated this way will be reclaimed either on the\n next call to Dart_ExitScope or when the native port handler exits.\n\n \\param size Size of the memory to allocate.\n\n \\return A pointer to the allocated memory. NULL if allocation\n   failed. Failure might due to is no current VM zone."]
    pub fn Dart_ScopeAllocate(size: isize) -> *mut u8;
}
unsafe extern "C" {
    #[doc = " Returns the null object.\n\n \\return A handle to the null object."]
    pub fn Dart_Null() -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Is this object null?"]
    pub fn Dart_IsNull(object: Dart_Handle) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns the empty string object.\n\n \\return A handle to the empty string object."]
    pub fn Dart_EmptyString() -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Returns types that are not classes, and which therefore cannot be looked up\n as library members by Dart_GetType.\n\n \\return A handle to the dynamic, void or Never type."]
    pub fn Dart_TypeDynamic() -> Dart_Handle;
}
unsafe extern "C" {
    pub fn Dart_TypeVoid() -> Dart_Handle;
}
unsafe extern "C" {
    pub fn Dart_TypeNever() -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Checks if the two objects are equal.\n\n The result of the comparison is returned through the 'equal'\n parameter. The return value itself is used to indicate success or\n failure, not equality.\n\n May generate an unhandled exception error.\n\n \\param obj1 An object to be compared.\n \\param obj2 An object to be compared.\n \\param equal Returns the result of the equality comparison.\n\n \\return A valid handle if no error occurs during the comparison."]
    pub fn Dart_ObjectEquals(obj1: Dart_Handle, obj2: Dart_Handle, equal: *mut bool)
    -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Is this object an instance of some type?\n\n The result of the test is returned through the 'instanceof' parameter.\n The return value itself is used to indicate success or failure.\n\n \\param object An object.\n \\param type A type.\n \\param instanceof Return true if 'object' is an instance of type 'type'.\n\n \\return A valid handle if no error occurs during the operation."]
    pub fn Dart_ObjectIsType(
        object: Dart_Handle,
        type_: Dart_Handle,
        instanceof: *mut bool,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Query object type.\n\n \\param object Some Object.\n\n \\return true if Object is of the specified type."]
    pub fn Dart_IsInstance(object: Dart_Handle) -> bool;
}
unsafe extern "C" {
    pub fn Dart_IsNumber(object: Dart_Handle) -> bool;
}
unsafe extern "C" {
    pub fn Dart_IsInteger(object: Dart_Handle) -> bool;
}
unsafe extern "C" {
    pub fn Dart_IsDouble(object: Dart_Handle) -> bool;
}
unsafe extern "C" {
    pub fn Dart_IsBoolean(object: Dart_Handle) -> bool;
}
unsafe extern "C" {
    pub fn Dart_IsString(object: Dart_Handle) -> bool;
}
unsafe extern "C" {
    pub fn Dart_IsStringLatin1(object: Dart_Handle) -> bool;
}
unsafe extern "C" {
    pub fn Dart_IsList(object: Dart_Handle) -> bool;
}
unsafe extern "C" {
    pub fn Dart_IsMap(object: Dart_Handle) -> bool;
}
unsafe extern "C" {
    pub fn Dart_IsLibrary(object: Dart_Handle) -> bool;
}
unsafe extern "C" {
    pub fn Dart_IsType(handle: Dart_Handle) -> bool;
}
unsafe extern "C" {
    pub fn Dart_IsFunction(handle: Dart_Handle) -> bool;
}
unsafe extern "C" {
    pub fn Dart_IsVariable(handle: Dart_Handle) -> bool;
}
unsafe extern "C" {
    pub fn Dart_IsTypeVariable(handle: Dart_Handle) -> bool;
}
unsafe extern "C" {
    pub fn Dart_IsClosure(object: Dart_Handle) -> bool;
}
unsafe extern "C" {
    pub fn Dart_IsTypedData(object: Dart_Handle) -> bool;
}
unsafe extern "C" {
    pub fn Dart_IsByteBuffer(object: Dart_Handle) -> bool;
}
unsafe extern "C" {
    pub fn Dart_IsFuture(object: Dart_Handle) -> bool;
}
unsafe extern "C" {
    #[doc = " Gets the type of a Dart language object.\n\n \\param instance Some Dart object.\n\n \\return If no error occurs, the type is returned. Otherwise an\n   error handle is returned."]
    pub fn Dart_InstanceGetType(instance: Dart_Handle) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Returns the name for the provided class type.\n\n \\return A valid string handle if no error occurs during the\n   operation."]
    pub fn Dart_ClassName(cls_type: Dart_Handle) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Returns the name for the provided function or method.\n\n \\return A valid string handle if no error occurs during the\n   operation."]
    pub fn Dart_FunctionName(function: Dart_Handle) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Returns a handle to the owner of a function.\n\n The owner of an instance method or a static method is its defining\n class. The owner of a top-level function is its defining\n library. The owner of the function of a non-implicit closure is the\n function of the method or closure that defines the non-implicit\n closure.\n\n \\return A valid handle to the owner of the function, or an error\n   handle if the argument is not a valid handle to a function."]
    pub fn Dart_FunctionOwner(function: Dart_Handle) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Determines whether a function handle refers to a static function\n of method.\n\n For the purposes of the embedding API, a top-level function is\n implicitly declared static.\n\n \\param function A handle to a function or method declaration.\n \\param is_static Returns whether the function or method is declared static.\n\n \\return A valid handle if no error occurs during the operation."]
    pub fn Dart_FunctionIsStatic(function: Dart_Handle, is_static: *mut bool) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Is this object a closure resulting from a tear-off (closurized method)?\n\n Returns true for closures produced when an ordinary method is accessed\n through a getter call. Returns false otherwise, in particular for closures\n produced from local function declarations.\n\n \\param object Some Object.\n\n \\return true if Object is a tear-off."]
    pub fn Dart_IsTearOff(object: Dart_Handle) -> bool;
}
unsafe extern "C" {
    #[doc = " Retrieves the function of a closure.\n\n \\return A handle to the function of the closure, or an error handle if the\n   argument is not a closure."]
    pub fn Dart_ClosureFunction(closure: Dart_Handle) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Returns a handle to the library which contains class.\n\n \\return A valid handle to the library with owns class, null if the class\n   has no library or an error handle if the argument is not a valid handle\n   to a class type."]
    pub fn Dart_ClassLibrary(cls_type: Dart_Handle) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Does this Integer fit into a 64-bit signed integer?\n\n \\param integer An integer.\n \\param fits Returns true if the integer fits into a 64-bit signed integer.\n\n \\return A valid handle if no error occurs during the operation."]
    pub fn Dart_IntegerFitsIntoInt64(integer: Dart_Handle, fits: *mut bool) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Does this Integer fit into a 64-bit unsigned integer?\n\n \\param integer An integer.\n \\param fits Returns true if the integer fits into a 64-bit unsigned integer.\n\n \\return A valid handle if no error occurs during the operation."]
    pub fn Dart_IntegerFitsIntoUint64(integer: Dart_Handle, fits: *mut bool) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Returns an Integer with the provided value.\n\n \\param value The value of the integer.\n\n \\return The Integer object if no error occurs. Otherwise returns\n   an error handle."]
    pub fn Dart_NewInteger(value: i64) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Returns an Integer with the provided value.\n\n \\param value The unsigned value of the integer.\n\n \\return The Integer object if no error occurs. Otherwise returns\n   an error handle."]
    pub fn Dart_NewIntegerFromUint64(value: u64) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Returns an Integer with the provided value.\n\n \\param value The value of the integer represented as a C string\n   containing a hexadecimal number.\n\n \\return The Integer object if no error occurs. Otherwise returns\n   an error handle."]
    pub fn Dart_NewIntegerFromHexCString(value: *const ::std::os::raw::c_char) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Gets the value of an Integer.\n\n The integer must fit into a 64-bit signed integer, otherwise an error occurs.\n\n \\param integer An Integer.\n \\param value Returns the value of the Integer.\n\n \\return A valid handle if no error occurs during the operation."]
    pub fn Dart_IntegerToInt64(integer: Dart_Handle, value: *mut i64) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Gets the value of an Integer.\n\n The integer must fit into a 64-bit unsigned integer, otherwise an\n error occurs.\n\n \\param integer An Integer.\n \\param value Returns the value of the Integer.\n\n \\return A valid handle if no error occurs during the operation."]
    pub fn Dart_IntegerToUint64(integer: Dart_Handle, value: *mut u64) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Gets the value of an integer as a hexadecimal C string.\n\n \\param integer An Integer.\n \\param value Returns the value of the Integer as a hexadecimal C\n   string. This C string is scope allocated and is only valid until\n   the next call to Dart_ExitScope.\n\n \\return A valid handle if no error occurs during the operation."]
    pub fn Dart_IntegerToHexCString(
        integer: Dart_Handle,
        value: *mut *const ::std::os::raw::c_char,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Returns a Double with the provided value.\n\n \\param value A double.\n\n \\return The Double object if no error occurs. Otherwise returns\n   an error handle."]
    pub fn Dart_NewDouble(value: f64) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Gets the value of a Double\n\n \\param double_obj A Double\n \\param value Returns the value of the Double.\n\n \\return A valid handle if no error occurs during the operation."]
    pub fn Dart_DoubleValue(double_obj: Dart_Handle, value: *mut f64) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Returns a closure of static function 'function_name' in the class 'class_name'\n in the exported namespace of specified 'library'.\n\n \\param library Library object\n \\param cls_type Type object representing a Class\n \\param function_name Name of the static function in the class\n\n \\return A valid Dart instance if no error occurs during the operation."]
    pub fn Dart_GetStaticMethodClosure(
        library: Dart_Handle,
        cls_type: Dart_Handle,
        function_name: Dart_Handle,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Returns the True object.\n\n Requires there to be a current isolate.\n\n \\return A handle to the True object."]
    pub fn Dart_True() -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Returns the False object.\n\n Requires there to be a current isolate.\n\n \\return A handle to the False object."]
    pub fn Dart_False() -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Returns a Boolean with the provided value.\n\n \\param value true or false.\n\n \\return The Boolean object if no error occurs. Otherwise returns\n   an error handle."]
    pub fn Dart_NewBoolean(value: bool) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Gets the value of a Boolean\n\n \\param boolean_obj A Boolean\n \\param value Returns the value of the Boolean.\n\n \\return A valid handle if no error occurs during the operation."]
    pub fn Dart_BooleanValue(boolean_obj: Dart_Handle, value: *mut bool) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Gets the length of a String.\n\n \\param str A String.\n \\param length Returns the length of the String.\n\n \\return A valid handle if no error occurs during the operation."]
    pub fn Dart_StringLength(str_: Dart_Handle, length: *mut isize) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Gets the length of UTF-8 encoded representation for a string.\n\n \\param str A String.\n \\param length Returns the length of UTF-8 encoded representation for string.\n\n \\return A valid handle if no error occurs during the operation."]
    pub fn Dart_StringUTF8Length(str_: Dart_Handle, length: *mut isize) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Returns a String built from the provided C string\n (There is an implicit assumption that the C string passed in contains\n  UTF-8 encoded characters and '\\0' is considered as a termination\n  character).\n\n \\param str A C String\n\n \\return The String object if no error occurs. Otherwise returns\n   an error handle."]
    pub fn Dart_NewStringFromCString(str_: *const ::std::os::raw::c_char) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Returns a String built from an array of UTF-8 encoded characters.\n\n \\param utf8_array An array of UTF-8 encoded characters.\n \\param length The length of the codepoints array.\n\n \\return The String object if no error occurs. Otherwise returns\n   an error handle."]
    pub fn Dart_NewStringFromUTF8(utf8_array: *const u8, length: isize) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Returns a String built from an array of UTF-16 encoded characters.\n\n \\param utf16_array An array of UTF-16 encoded characters.\n \\param length The length of the codepoints array.\n\n \\return The String object if no error occurs. Otherwise returns\n   an error handle."]
    pub fn Dart_NewStringFromUTF16(utf16_array: *const u16, length: isize) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Returns a String built from an array of UTF-32 encoded characters.\n\n \\param utf32_array An array of UTF-32 encoded characters.\n \\param length The length of the codepoints array.\n\n \\return The String object if no error occurs. Otherwise returns\n   an error handle."]
    pub fn Dart_NewStringFromUTF32(utf32_array: *const i32, length: isize) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Gets the C string representation of a String.\n (It is a sequence of UTF-8 encoded values with a '\\0' termination.)\n\n \\param str A string.\n \\param cstr Returns the String represented as a C string.\n   This C string is scope allocated and is only valid until\n   the next call to Dart_ExitScope.\n\n \\return A valid handle if no error occurs during the operation."]
    pub fn Dart_StringToCString(
        str_: Dart_Handle,
        cstr: *mut *const ::std::os::raw::c_char,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Gets a UTF-8 encoded representation of a String.\n\n Any unpaired surrogate code points in the string will be converted as\n replacement characters (U+FFFD, 0xEF 0xBF 0xBD in UTF-8). If you need\n to preserve unpaired surrogates, use the Dart_StringToUTF16 function.\n\n \\param str A string.\n \\param utf8_array Returns the String represented as UTF-8 code\n   units.  This UTF-8 array is scope allocated and is only valid\n   until the next call to Dart_ExitScope.\n \\param length Used to return the length of the array which was\n   actually used.\n\n \\return A valid handle if no error occurs during the operation."]
    pub fn Dart_StringToUTF8(
        str_: Dart_Handle,
        utf8_array: *mut *mut u8,
        length: *mut isize,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Copies the UTF-8 encoded representation of a String into specified buffer.\n\n Any unpaired surrogate code points in the string will be converted as\n replacement characters (U+FFFD, 0xEF 0xBF 0xBD in UTF-8).\n\n \\param str A string.\n \\param utf8_array Buffer into which the UTF-8 encoded representation of\n   the string is copied into.\n   The buffer is allocated and managed by the caller.\n \\param length Specifies the length of the buffer passed in.\n\n \\return A valid handle if no error occurs during the operation."]
    pub fn Dart_CopyUTF8EncodingOfString(
        str_: Dart_Handle,
        utf8_array: *mut u8,
        length: isize,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Gets the data corresponding to the string object. This function returns\n the data only for Latin-1 (ISO-8859-1) string objects. For all other\n string objects it returns an error.\n\n \\param str A string.\n \\param latin1_array An array allocated by the caller, used to return\n   the string data.\n \\param length Used to pass in the length of the provided array.\n   Used to return the length of the array which was actually used.\n\n \\return A valid handle if no error occurs during the operation."]
    pub fn Dart_StringToLatin1(
        str_: Dart_Handle,
        latin1_array: *mut u8,
        length: *mut isize,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Gets the UTF-16 encoded representation of a string.\n\n \\param str A string.\n \\param utf16_array An array allocated by the caller, used to return\n   the array of UTF-16 encoded characters.\n \\param length Used to pass in the length of the provided array.\n   Used to return the length of the array which was actually used.\n\n \\return A valid handle if no error occurs during the operation."]
    pub fn Dart_StringToUTF16(
        str_: Dart_Handle,
        utf16_array: *mut u16,
        length: *mut isize,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Gets the storage size in bytes of a String.\n\n \\param str A String.\n \\param size Returns the storage size in bytes of the String.\n  This is the size in bytes needed to store the String.\n\n \\return A valid handle if no error occurs during the operation."]
    pub fn Dart_StringStorageSize(str_: Dart_Handle, size: *mut isize) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Retrieves some properties associated with a String.\n Properties retrieved are:\n - character size of the string (one or two byte)\n - length of the string\n - peer pointer of string if it is an external string.\n \\param str A String.\n \\param char_size Returns the character size of the String.\n \\param str_len Returns the length of the String.\n \\param peer Returns the peer pointer associated with the String or 0 if\n   there is no peer pointer for it.\n \\return Success if no error occurs. Otherwise returns\n   an error handle."]
    pub fn Dart_StringGetProperties(
        str_: Dart_Handle,
        char_size: *mut isize,
        str_len: *mut isize,
        peer: *mut *mut ::std::os::raw::c_void,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Returns a List<dynamic> of the desired length.\n\n \\param length The length of the list.\n\n \\return The List object if no error occurs. Otherwise returns\n   an error handle."]
    pub fn Dart_NewList(length: isize) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Returns a List of the desired length with the desired element type.\n\n \\param element_type Handle to a nullable type object. E.g., from\n Dart_GetType or Dart_GetNullableType.\n\n \\param length The length of the list.\n\n \\return The List object if no error occurs. Otherwise returns\n   an error handle."]
    pub fn Dart_NewListOfType(element_type: Dart_Handle, length: isize) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Returns a List of the desired length with the desired element type, filled\n with the provided object.\n\n \\param element_type Handle to a type object. E.g., from Dart_GetType.\n\n \\param fill_object Handle to an object of type 'element_type' that will be\n used to populate the list. This parameter can only be Dart_Null() if the\n length of the list is 0 or 'element_type' is a nullable type.\n\n \\param length The length of the list.\n\n \\return The List object if no error occurs. Otherwise returns\n   an error handle."]
    pub fn Dart_NewListOfTypeFilled(
        element_type: Dart_Handle,
        fill_object: Dart_Handle,
        length: isize,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Gets the length of a List.\n\n May generate an unhandled exception error.\n\n \\param list A List.\n \\param length Returns the length of the List.\n\n \\return A valid handle if no error occurs during the operation."]
    pub fn Dart_ListLength(list: Dart_Handle, length: *mut isize) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Gets the Object at some index of a List.\n\n If the index is out of bounds, an error occurs.\n\n May generate an unhandled exception error.\n\n \\param list A List.\n \\param index A valid index into the List.\n\n \\return The Object in the List at the specified index if no error\n   occurs. Otherwise returns an error handle."]
    pub fn Dart_ListGetAt(list: Dart_Handle, index: isize) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Gets a range of Objects from a List.\n\n If any of the requested index values are out of bounds, an error occurs.\n\n May generate an unhandled exception error.\n\n \\param list A List.\n \\param offset The offset of the first item to get.\n \\param length The number of items to get.\n \\param result A pointer to fill with the objects.\n\n \\return Success if no error occurs during the operation."]
    pub fn Dart_ListGetRange(
        list: Dart_Handle,
        offset: isize,
        length: isize,
        result: *mut Dart_Handle,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Sets the Object at some index of a List.\n\n If the index is out of bounds, an error occurs.\n\n May generate an unhandled exception error.\n\n \\param list A List.\n \\param index A valid index into the List.\n \\param value The Object to put in the List.\n\n \\return A valid handle if no error occurs during the operation."]
    pub fn Dart_ListSetAt(list: Dart_Handle, index: isize, value: Dart_Handle) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " May generate an unhandled exception error."]
    pub fn Dart_ListGetAsBytes(
        list: Dart_Handle,
        offset: isize,
        native_array: *mut u8,
        length: isize,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " May generate an unhandled exception error."]
    pub fn Dart_ListSetAsBytes(
        list: Dart_Handle,
        offset: isize,
        native_array: *const u8,
        length: isize,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Gets the Object at some key of a Map.\n\n May generate an unhandled exception error.\n\n \\param map A Map.\n \\param key An Object.\n\n \\return The value in the map at the specified key, null if the map does not\n   contain the key, or an error handle."]
    pub fn Dart_MapGetAt(map: Dart_Handle, key: Dart_Handle) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Returns whether the Map contains a given key.\n\n May generate an unhandled exception error.\n\n \\param map A Map.\n\n \\return A handle on a boolean indicating whether map contains the key.\n   Otherwise returns an error handle."]
    pub fn Dart_MapContainsKey(map: Dart_Handle, key: Dart_Handle) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Gets the list of keys of a Map.\n\n May generate an unhandled exception error.\n\n \\param map A Map.\n\n \\return The list of key Objects if no error occurs. Otherwise returns an\n   error handle."]
    pub fn Dart_MapKeys(map: Dart_Handle) -> Dart_Handle;
}
pub const Dart_TypedData_Type_Dart_TypedData_kByteData: Dart_TypedData_Type = 0;
pub const Dart_TypedData_Type_Dart_TypedData_kInt8: Dart_TypedData_Type = 1;
pub const Dart_TypedData_Type_Dart_TypedData_kUint8: Dart_TypedData_Type = 2;
pub const Dart_TypedData_Type_Dart_TypedData_kUint8Clamped: Dart_TypedData_Type = 3;
pub const Dart_TypedData_Type_Dart_TypedData_kInt16: Dart_TypedData_Type = 4;
pub const Dart_TypedData_Type_Dart_TypedData_kUint16: Dart_TypedData_Type = 5;
pub const Dart_TypedData_Type_Dart_TypedData_kInt32: Dart_TypedData_Type = 6;
pub const Dart_TypedData_Type_Dart_TypedData_kUint32: Dart_TypedData_Type = 7;
pub const Dart_TypedData_Type_Dart_TypedData_kInt64: Dart_TypedData_Type = 8;
pub const Dart_TypedData_Type_Dart_TypedData_kUint64: Dart_TypedData_Type = 9;
pub const Dart_TypedData_Type_Dart_TypedData_kFloat32: Dart_TypedData_Type = 10;
pub const Dart_TypedData_Type_Dart_TypedData_kFloat64: Dart_TypedData_Type = 11;
pub const Dart_TypedData_Type_Dart_TypedData_kInt32x4: Dart_TypedData_Type = 12;
pub const Dart_TypedData_Type_Dart_TypedData_kFloat32x4: Dart_TypedData_Type = 13;
pub const Dart_TypedData_Type_Dart_TypedData_kFloat64x2: Dart_TypedData_Type = 14;
pub const Dart_TypedData_Type_Dart_TypedData_kInvalid: Dart_TypedData_Type = 15;
pub type Dart_TypedData_Type = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " Return type if this object is a TypedData object.\n\n \\return kInvalid if the object is not a TypedData object or the appropriate\n   Dart_TypedData_Type."]
    pub fn Dart_GetTypeOfTypedData(object: Dart_Handle) -> Dart_TypedData_Type;
}
unsafe extern "C" {
    #[doc = " Return type if this object is an external TypedData object.\n\n \\return kInvalid if the object is not an external TypedData object or\n   the appropriate Dart_TypedData_Type."]
    pub fn Dart_GetTypeOfExternalTypedData(object: Dart_Handle) -> Dart_TypedData_Type;
}
unsafe extern "C" {
    #[doc = " Returns a TypedData object of the desired length and type.\n\n \\param type The type of the TypedData object.\n \\param length The length of the TypedData object (length in type units).\n\n \\return The TypedData object if no error occurs. Otherwise returns\n   an error handle."]
    pub fn Dart_NewTypedData(type_: Dart_TypedData_Type, length: isize) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Returns a TypedData object which references an external data array.\n\n \\param type The type of the data array.\n \\param data A data array. This array must not move.\n \\param length The length of the data array (length in type units).\n\n \\return The TypedData object if no error occurs. Otherwise returns\n   an error handle."]
    pub fn Dart_NewExternalTypedData(
        type_: Dart_TypedData_Type,
        data: *mut ::std::os::raw::c_void,
        length: isize,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Returns a TypedData object which references an external data array.\n\n \\param type The type of the data array.\n \\param data A data array. This array must not move.\n \\param length The length of the data array (length in type units).\n \\param peer A pointer to a native object or NULL.  This value is\n   provided to callback when it is invoked.\n \\param external_allocation_size The number of externally allocated\n   bytes for peer. Used to inform the garbage collector.\n \\param callback A function pointer that will be invoked sometime\n   after the object is garbage collected, unless the handle has been deleted.\n   A valid callback needs to be specified it cannot be NULL.\n\n \\return The TypedData object if no error occurs. Otherwise returns\n   an error handle."]
    pub fn Dart_NewExternalTypedDataWithFinalizer(
        type_: Dart_TypedData_Type,
        data: *mut ::std::os::raw::c_void,
        length: isize,
        peer: *mut ::std::os::raw::c_void,
        external_allocation_size: isize,
        callback: Dart_HandleFinalizer,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    pub fn Dart_NewUnmodifiableExternalTypedDataWithFinalizer(
        type_: Dart_TypedData_Type,
        data: *const ::std::os::raw::c_void,
        length: isize,
        peer: *mut ::std::os::raw::c_void,
        external_allocation_size: isize,
        callback: Dart_HandleFinalizer,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Returns a ByteBuffer object for the typed data.\n\n \\param typed_data The TypedData object.\n\n \\return The ByteBuffer object if no error occurs. Otherwise returns\n   an error handle."]
    pub fn Dart_NewByteBuffer(typed_data: Dart_Handle) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Acquires access to the internal data address of a TypedData object.\n\n \\param object The typed data object whose internal data address is to\n    be accessed.\n \\param type The type of the object is returned here.\n \\param data The internal data address is returned here.\n \\param len Size of the typed array is returned here.\n\n Notes:\n   When the internal address of the object is acquired any calls to a\n   Dart API function that could potentially allocate an object or run\n   any Dart code will return an error.\n\n   Any Dart API functions for accessing the data should not be called\n   before the corresponding release. In particular, the object should\n   not be acquired again before its release. This leads to undefined\n   behavior.\n\n \\return Success if the internal data address is acquired successfully.\n   Otherwise, returns an error handle."]
    pub fn Dart_TypedDataAcquireData(
        object: Dart_Handle,
        type_: *mut Dart_TypedData_Type,
        data: *mut *mut ::std::os::raw::c_void,
        len: *mut isize,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Releases access to the internal data address that was acquired earlier using\n Dart_TypedDataAcquireData.\n\n \\param object The typed data object whose internal data address is to be\n   released.\n\n \\return Success if the internal data address is released successfully.\n   Otherwise, returns an error handle."]
    pub fn Dart_TypedDataReleaseData(object: Dart_Handle) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Returns the TypedData object associated with the ByteBuffer object.\n\n \\param byte_buffer The ByteBuffer object.\n\n \\return The TypedData object if no error occurs. Otherwise returns\n   an error handle."]
    pub fn Dart_GetDataFromByteBuffer(byte_buffer: Dart_Handle) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Invokes a constructor, creating a new object.\n\n This function allows hidden constructors (constructors with leading\n underscores) to be called.\n\n \\param type Type of object to be constructed.\n \\param constructor_name The name of the constructor to invoke.  Use\n   Dart_Null() or Dart_EmptyString() to invoke the unnamed constructor.\n   This name should not include the name of the class.\n \\param number_of_arguments Size of the arguments array.\n \\param arguments An array of arguments to the constructor.\n\n \\return If the constructor is called and completes successfully,\n   then the new object. If an error occurs during execution, then an\n   error handle is returned."]
    pub fn Dart_New(
        type_: Dart_Handle,
        constructor_name: Dart_Handle,
        number_of_arguments: ::std::os::raw::c_int,
        arguments: *mut Dart_Handle,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Allocate a new object without invoking a constructor.\n\n \\param type The type of an object to be allocated.\n\n \\return The new object. If an error occurs during execution, then an\n   error handle is returned."]
    pub fn Dart_Allocate(type_: Dart_Handle) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Allocate a new object without invoking a constructor, and sets specified\n  native fields.\n\n \\param type The type of an object to be allocated.\n \\param num_native_fields The number of native fields to set.\n \\param native_fields An array containing the value of native fields.\n\n \\return The new object. If an error occurs during execution, then an\n   error handle is returned."]
    pub fn Dart_AllocateWithNativeFields(
        type_: Dart_Handle,
        num_native_fields: isize,
        native_fields: *const isize,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Invokes a method or function.\n\n The 'target' parameter may be an object, type, or library.  If\n 'target' is an object, then this function will invoke an instance\n method.  If 'target' is a type, then this function will invoke a\n static method.  If 'target' is a library, then this function will\n invoke a top-level function from that library.\n NOTE: This API call cannot be used to invoke methods of a type object.\n\n This function ignores visibility (leading underscores in names).\n\n May generate an unhandled exception error.\n\n \\param target An object, type, or library.\n \\param name The name of the function or method to invoke.\n \\param number_of_arguments Size of the arguments array.\n \\param arguments An array of arguments to the function.\n\n \\return If the function or method is called and completes\n   successfully, then the return value is returned. If an error\n   occurs during execution, then an error handle is returned."]
    pub fn Dart_Invoke(
        target: Dart_Handle,
        name: Dart_Handle,
        number_of_arguments: ::std::os::raw::c_int,
        arguments: *mut Dart_Handle,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Invokes a Closure with the given arguments.\n\n May generate an unhandled exception error.\n\n \\return If no error occurs during execution, then the result of\n   invoking the closure is returned. If an error occurs during\n   execution, then an error handle is returned."]
    pub fn Dart_InvokeClosure(
        closure: Dart_Handle,
        number_of_arguments: ::std::os::raw::c_int,
        arguments: *mut Dart_Handle,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Invokes a Generative Constructor on an object that was previously\n allocated using Dart_Allocate/Dart_AllocateWithNativeFields.\n\n The 'object' parameter must be an object.\n\n This function ignores visibility (leading underscores in names).\n\n May generate an unhandled exception error.\n\n \\param object An object.\n \\param name The name of the constructor to invoke.\n   Use Dart_Null() or Dart_EmptyString() to invoke the unnamed constructor.\n \\param number_of_arguments Size of the arguments array.\n \\param arguments An array of arguments to the function.\n\n \\return If the constructor is called and completes\n   successfully, then the object is returned. If an error\n   occurs during execution, then an error handle is returned."]
    pub fn Dart_InvokeConstructor(
        object: Dart_Handle,
        name: Dart_Handle,
        number_of_arguments: ::std::os::raw::c_int,
        arguments: *mut Dart_Handle,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Gets the value of a field.\n\n The 'container' parameter may be an object, type, or library.  If\n 'container' is an object, then this function will access an\n instance field.  If 'container' is a type, then this function will\n access a static field.  If 'container' is a library, then this\n function will access a top-level variable.\n NOTE: This API call cannot be used to access fields of a type object.\n\n This function ignores field visibility (leading underscores in names).\n\n May generate an unhandled exception error.\n\n \\param container An object, type, or library.\n \\param name A field name.\n\n \\return If no error occurs, then the value of the field is\n   returned. Otherwise an error handle is returned."]
    pub fn Dart_GetField(container: Dart_Handle, name: Dart_Handle) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Sets the value of a field.\n\n The 'container' parameter may actually be an object, type, or\n library.  If 'container' is an object, then this function will\n access an instance field.  If 'container' is a type, then this\n function will access a static field.  If 'container' is a library,\n then this function will access a top-level variable.\n NOTE: This API call cannot be used to access fields of a type object.\n\n This function ignores field visibility (leading underscores in names).\n\n May generate an unhandled exception error.\n\n \\param container An object, type, or library.\n \\param name A field name.\n \\param value The new field value.\n\n \\return A valid handle if no error occurs."]
    pub fn Dart_SetField(
        container: Dart_Handle,
        name: Dart_Handle,
        value: Dart_Handle,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Throws an exception.\n\n This function causes a Dart language exception to be thrown. This\n will proceed in the standard way, walking up Dart frames until an\n appropriate 'catch' block is found, executing 'finally' blocks,\n etc.\n\n If an error handle is passed into this function, the error is\n propagated immediately.  See Dart_PropagateError for a discussion\n of error propagation.\n\n If successful, this function does not return. Note that this means\n that the destructors of any stack-allocated C++ objects will not be\n called. If there are no Dart frames on the stack, an error occurs.\n\n \\return An error handle if the exception was not thrown.\n   Otherwise the function does not return."]
    pub fn Dart_ThrowException(exception: Dart_Handle) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Rethrows an exception.\n\n Rethrows an exception, unwinding all dart frames on the stack. If\n successful, this function does not return. Note that this means\n that the destructors of any stack-allocated C++ objects will not be\n called. If there are no Dart frames on the stack, an error occurs.\n\n \\return An error handle if the exception was not thrown.\n   Otherwise the function does not return."]
    pub fn Dart_ReThrowException(exception: Dart_Handle, stacktrace: Dart_Handle) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Gets the number of native instance fields in an object."]
    pub fn Dart_GetNativeInstanceFieldCount(
        obj: Dart_Handle,
        count: *mut ::std::os::raw::c_int,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Gets the value of a native field.\n\n TODO(turnidge): Document."]
    pub fn Dart_GetNativeInstanceField(
        obj: Dart_Handle,
        index: ::std::os::raw::c_int,
        value: *mut isize,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Sets the value of a native field.\n\n TODO(turnidge): Document."]
    pub fn Dart_SetNativeInstanceField(
        obj: Dart_Handle,
        index: ::std::os::raw::c_int,
        value: isize,
    ) -> Dart_Handle;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Dart_NativeArguments {
    _unused: [u8; 0],
}
#[doc = " The arguments to a native function.\n\n This object is passed to a native function to represent its\n arguments and return value. It allows access to the arguments to a\n native function by index. It also allows the return value of a\n native function to be set."]
pub type Dart_NativeArguments = *mut _Dart_NativeArguments;
unsafe extern "C" {
    #[doc = " Extracts current isolate group data from the native arguments structure."]
    pub fn Dart_GetNativeIsolateGroupData(
        args: Dart_NativeArguments,
    ) -> *mut ::std::os::raw::c_void;
}
pub const Dart_NativeArgument_Type_Dart_NativeArgument_kBool: Dart_NativeArgument_Type = 0;
pub const Dart_NativeArgument_Type_Dart_NativeArgument_kInt32: Dart_NativeArgument_Type = 1;
pub const Dart_NativeArgument_Type_Dart_NativeArgument_kUint32: Dart_NativeArgument_Type = 2;
pub const Dart_NativeArgument_Type_Dart_NativeArgument_kInt64: Dart_NativeArgument_Type = 3;
pub const Dart_NativeArgument_Type_Dart_NativeArgument_kUint64: Dart_NativeArgument_Type = 4;
pub const Dart_NativeArgument_Type_Dart_NativeArgument_kDouble: Dart_NativeArgument_Type = 5;
pub const Dart_NativeArgument_Type_Dart_NativeArgument_kString: Dart_NativeArgument_Type = 6;
pub const Dart_NativeArgument_Type_Dart_NativeArgument_kInstance: Dart_NativeArgument_Type = 7;
pub const Dart_NativeArgument_Type_Dart_NativeArgument_kNativeFields: Dart_NativeArgument_Type = 8;
pub type Dart_NativeArgument_Type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Dart_NativeArgument_Descriptor {
    pub type_: u8,
    pub index: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _Dart_NativeArgument_Descriptor"]
        [::std::mem::size_of::<_Dart_NativeArgument_Descriptor>() - 2usize];
    ["Alignment of _Dart_NativeArgument_Descriptor"]
        [::std::mem::align_of::<_Dart_NativeArgument_Descriptor>() - 1usize];
    ["Offset of field: _Dart_NativeArgument_Descriptor::type_"]
        [::std::mem::offset_of!(_Dart_NativeArgument_Descriptor, type_) - 0usize];
    ["Offset of field: _Dart_NativeArgument_Descriptor::index"]
        [::std::mem::offset_of!(_Dart_NativeArgument_Descriptor, index) - 1usize];
};
pub type Dart_NativeArgument_Descriptor = _Dart_NativeArgument_Descriptor;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _Dart_NativeArgument_Value {
    pub as_bool: bool,
    pub as_int32: i32,
    pub as_uint32: u32,
    pub as_int64: i64,
    pub as_uint64: u64,
    pub as_double: f64,
    pub as_string: _Dart_NativeArgument_Value__bindgen_ty_1,
    pub as_native_fields: _Dart_NativeArgument_Value__bindgen_ty_2,
    pub as_instance: Dart_Handle,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Dart_NativeArgument_Value__bindgen_ty_1 {
    pub dart_str: Dart_Handle,
    pub peer: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _Dart_NativeArgument_Value__bindgen_ty_1"]
        [::std::mem::size_of::<_Dart_NativeArgument_Value__bindgen_ty_1>() - 16usize];
    ["Alignment of _Dart_NativeArgument_Value__bindgen_ty_1"]
        [::std::mem::align_of::<_Dart_NativeArgument_Value__bindgen_ty_1>() - 8usize];
    ["Offset of field: _Dart_NativeArgument_Value__bindgen_ty_1::dart_str"]
        [::std::mem::offset_of!(_Dart_NativeArgument_Value__bindgen_ty_1, dart_str) - 0usize];
    ["Offset of field: _Dart_NativeArgument_Value__bindgen_ty_1::peer"]
        [::std::mem::offset_of!(_Dart_NativeArgument_Value__bindgen_ty_1, peer) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Dart_NativeArgument_Value__bindgen_ty_2 {
    pub num_fields: isize,
    pub values: *mut isize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _Dart_NativeArgument_Value__bindgen_ty_2"]
        [::std::mem::size_of::<_Dart_NativeArgument_Value__bindgen_ty_2>() - 16usize];
    ["Alignment of _Dart_NativeArgument_Value__bindgen_ty_2"]
        [::std::mem::align_of::<_Dart_NativeArgument_Value__bindgen_ty_2>() - 8usize];
    ["Offset of field: _Dart_NativeArgument_Value__bindgen_ty_2::num_fields"]
        [::std::mem::offset_of!(_Dart_NativeArgument_Value__bindgen_ty_2, num_fields) - 0usize];
    ["Offset of field: _Dart_NativeArgument_Value__bindgen_ty_2::values"]
        [::std::mem::offset_of!(_Dart_NativeArgument_Value__bindgen_ty_2, values) - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _Dart_NativeArgument_Value"]
        [::std::mem::size_of::<_Dart_NativeArgument_Value>() - 16usize];
    ["Alignment of _Dart_NativeArgument_Value"]
        [::std::mem::align_of::<_Dart_NativeArgument_Value>() - 8usize];
    ["Offset of field: _Dart_NativeArgument_Value::as_bool"]
        [::std::mem::offset_of!(_Dart_NativeArgument_Value, as_bool) - 0usize];
    ["Offset of field: _Dart_NativeArgument_Value::as_int32"]
        [::std::mem::offset_of!(_Dart_NativeArgument_Value, as_int32) - 0usize];
    ["Offset of field: _Dart_NativeArgument_Value::as_uint32"]
        [::std::mem::offset_of!(_Dart_NativeArgument_Value, as_uint32) - 0usize];
    ["Offset of field: _Dart_NativeArgument_Value::as_int64"]
        [::std::mem::offset_of!(_Dart_NativeArgument_Value, as_int64) - 0usize];
    ["Offset of field: _Dart_NativeArgument_Value::as_uint64"]
        [::std::mem::offset_of!(_Dart_NativeArgument_Value, as_uint64) - 0usize];
    ["Offset of field: _Dart_NativeArgument_Value::as_double"]
        [::std::mem::offset_of!(_Dart_NativeArgument_Value, as_double) - 0usize];
    ["Offset of field: _Dart_NativeArgument_Value::as_string"]
        [::std::mem::offset_of!(_Dart_NativeArgument_Value, as_string) - 0usize];
    ["Offset of field: _Dart_NativeArgument_Value::as_native_fields"]
        [::std::mem::offset_of!(_Dart_NativeArgument_Value, as_native_fields) - 0usize];
    ["Offset of field: _Dart_NativeArgument_Value::as_instance"]
        [::std::mem::offset_of!(_Dart_NativeArgument_Value, as_instance) - 0usize];
};
pub type Dart_NativeArgument_Value = _Dart_NativeArgument_Value;
pub const kNativeArgNumberPos: _bindgen_ty_1 = 0;
pub const kNativeArgNumberSize: _bindgen_ty_1 = 8;
pub const kNativeArgTypePos: _bindgen_ty_1 = 8;
pub const kNativeArgTypeSize: _bindgen_ty_1 = 8;
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " Gets the native arguments based on the types passed in and populates\n the passed arguments buffer with appropriate native values.\n\n \\param args the Native arguments block passed into the native call.\n \\param num_arguments length of argument descriptor array and argument\n   values array passed in.\n \\param arg_descriptors an array that describes the arguments that\n   need to be retrieved. For each argument to be retrieved the descriptor\n   contains the argument number (0, 1 etc.) and the argument type\n   described using Dart_NativeArgument_Type, e.g:\n   DART_NATIVE_ARG_DESCRIPTOR(Dart_NativeArgument_kBool, 1) indicates\n   that the first argument is to be retrieved and it should be a boolean.\n \\param arg_values array into which the native arguments need to be\n   extracted into, the array is allocated by the caller (it could be\n   stack allocated to avoid the malloc/free performance overhead).\n\n \\return Success if all the arguments could be extracted correctly,\n   returns an error handle if there were any errors while extracting the\n   arguments (mismatched number of arguments, incorrect types, etc.)."]
    pub fn Dart_GetNativeArguments(
        args: Dart_NativeArguments,
        num_arguments: ::std::os::raw::c_int,
        arg_descriptors: *const Dart_NativeArgument_Descriptor,
        arg_values: *mut Dart_NativeArgument_Value,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Gets the native argument at some index."]
    pub fn Dart_GetNativeArgument(
        args: Dart_NativeArguments,
        index: ::std::os::raw::c_int,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Gets the number of native arguments."]
    pub fn Dart_GetNativeArgumentCount(args: Dart_NativeArguments) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Gets all the native fields of the native argument at some index.\n \\param args Native arguments structure.\n \\param arg_index Index of the desired argument in the structure above.\n \\param num_fields size of the intptr_t array 'field_values' passed in.\n \\param field_values intptr_t array in which native field values are returned.\n \\return Success if the native fields where copied in successfully. Otherwise\n   returns an error handle. On success the native field values are copied\n   into the 'field_values' array, if the argument at 'arg_index' is a\n   null object then 0 is copied as the native field values into the\n   'field_values' array."]
    pub fn Dart_GetNativeFieldsOfArgument(
        args: Dart_NativeArguments,
        arg_index: ::std::os::raw::c_int,
        num_fields: ::std::os::raw::c_int,
        field_values: *mut isize,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Gets the native field of the receiver."]
    pub fn Dart_GetNativeReceiver(args: Dart_NativeArguments, value: *mut isize) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Gets a string native argument at some index.\n \\param args Native arguments structure.\n \\param arg_index Index of the desired argument in the structure above.\n \\param peer Returns the peer pointer if the string argument has one.\n \\return Success if the string argument has a peer, if it does not\n   have a peer then the String object is returned. Otherwise returns\n   an error handle (argument is not a String object)."]
    pub fn Dart_GetNativeStringArgument(
        args: Dart_NativeArguments,
        arg_index: ::std::os::raw::c_int,
        peer: *mut *mut ::std::os::raw::c_void,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Gets an integer native argument at some index.\n \\param args Native arguments structure.\n \\param index Index of the desired argument in the structure above.\n \\param value Returns the integer value if the argument is an Integer.\n \\return Success if no error occurs. Otherwise returns an error handle."]
    pub fn Dart_GetNativeIntegerArgument(
        args: Dart_NativeArguments,
        index: ::std::os::raw::c_int,
        value: *mut i64,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Gets a boolean native argument at some index.\n \\param args Native arguments structure.\n \\param index Index of the desired argument in the structure above.\n \\param value Returns the boolean value if the argument is a Boolean.\n \\return Success if no error occurs. Otherwise returns an error handle."]
    pub fn Dart_GetNativeBooleanArgument(
        args: Dart_NativeArguments,
        index: ::std::os::raw::c_int,
        value: *mut bool,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Gets a double native argument at some index.\n \\param args Native arguments structure.\n \\param index Index of the desired argument in the structure above.\n \\param value Returns the double value if the argument is a double.\n \\return Success if no error occurs. Otherwise returns an error handle."]
    pub fn Dart_GetNativeDoubleArgument(
        args: Dart_NativeArguments,
        index: ::std::os::raw::c_int,
        value: *mut f64,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Sets the return value for a native function.\n\n If retval is an Error handle, then error will be propagated once\n the native functions exits. See Dart_PropagateError for a\n discussion of how different types of errors are propagated."]
    pub fn Dart_SetReturnValue(args: Dart_NativeArguments, retval: Dart_Handle);
}
unsafe extern "C" {
    pub fn Dart_SetWeakHandleReturnValue(
        args: Dart_NativeArguments,
        rval: Dart_WeakPersistentHandle,
    );
}
unsafe extern "C" {
    pub fn Dart_SetBooleanReturnValue(args: Dart_NativeArguments, retval: bool);
}
unsafe extern "C" {
    pub fn Dart_SetIntegerReturnValue(args: Dart_NativeArguments, retval: i64);
}
unsafe extern "C" {
    pub fn Dart_SetDoubleReturnValue(args: Dart_NativeArguments, retval: f64);
}
#[doc = " A native function."]
pub type Dart_NativeFunction =
    ::std::option::Option<unsafe extern "C" fn(arguments: Dart_NativeArguments)>;
#[doc = " Native entry resolution callback.\n\n For libraries and scripts which have native functions, the embedder\n can provide a native entry resolver. This callback is used to map a\n name/arity to a Dart_NativeFunction. If no function is found, the\n callback should return NULL.\n\n The parameters to the native resolver function are:\n \\param name a Dart string which is the name of the native function.\n \\param num_of_arguments is the number of arguments expected by the\n   native function.\n \\param auto_setup_scope is a boolean flag that can be set by the resolver\n   to indicate if this function needs a Dart API scope (see Dart_EnterScope/\n   Dart_ExitScope) to be setup automatically by the VM before calling into\n   the native function. By default most native functions would require this\n   to be true but some light weight native functions which do not call back\n   into the VM through the Dart API may not require a Dart scope to be\n   setup automatically.\n\n \\return A valid Dart_NativeFunction which resolves to a native entry point\n   for the native function.\n\n See Dart_SetNativeResolver."]
pub type Dart_NativeEntryResolver = ::std::option::Option<
    unsafe extern "C" fn(
        name: Dart_Handle,
        num_of_arguments: ::std::os::raw::c_int,
        auto_setup_scope: *mut bool,
    ) -> Dart_NativeFunction,
>;
#[doc = " Native entry symbol lookup callback.\n\n For libraries and scripts which have native functions, the embedder\n can provide a callback for mapping a native entry to a symbol. This callback\n maps a native function entry PC to the native function name. If no native\n entry symbol can be found, the callback should return NULL.\n\n The parameters to the native reverse resolver function are:\n \\param nf A Dart_NativeFunction.\n\n \\return A const UTF-8 string containing the symbol name or NULL.\n\n See Dart_SetNativeResolver."]
pub type Dart_NativeEntrySymbol =
    ::std::option::Option<unsafe extern "C" fn(nf: Dart_NativeFunction) -> *const u8>;
#[doc = " FFI Native C function pointer resolver callback.\n\n See Dart_SetFfiNativeResolver."]
pub type Dart_FfiNativeResolver = ::std::option::Option<
    unsafe extern "C" fn(
        name: *const ::std::os::raw::c_char,
        args_n: usize,
    ) -> *mut ::std::os::raw::c_void,
>;
#[doc = " An environment lookup callback function.\n\n \\param name The name of the value to lookup in the environment.\n\n \\return A valid handle to a string if the name exists in the\n current environment or Dart_Null() if not."]
pub type Dart_EnvironmentCallback =
    ::std::option::Option<unsafe extern "C" fn(name: Dart_Handle) -> Dart_Handle>;
unsafe extern "C" {
    #[doc = " Sets the environment callback for the current isolate. This\n callback is used to lookup environment values by name in the\n current environment. This enables the embedder to supply values for\n the const constructors bool.fromEnvironment, int.fromEnvironment\n and String.fromEnvironment."]
    pub fn Dart_SetEnvironmentCallback(callback: Dart_EnvironmentCallback) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Sets the callback used to resolve native functions for a library.\n\n \\param library A library.\n \\param resolver A native entry resolver.\n\n \\return A valid handle if the native resolver was set successfully."]
    pub fn Dart_SetNativeResolver(
        library: Dart_Handle,
        resolver: Dart_NativeEntryResolver,
        symbol: Dart_NativeEntrySymbol,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Returns the callback used to resolve native functions for a library.\n\n \\param library A library.\n \\param resolver a pointer to a Dart_NativeEntryResolver\n\n \\return A valid handle if the library was found."]
    pub fn Dart_GetNativeResolver(
        library: Dart_Handle,
        resolver: *mut Dart_NativeEntryResolver,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Returns the callback used to resolve native function symbols for a library.\n\n \\param library A library.\n \\param resolver a pointer to a Dart_NativeEntrySymbol.\n\n \\return A valid handle if the library was found."]
    pub fn Dart_GetNativeSymbol(
        library: Dart_Handle,
        resolver: *mut Dart_NativeEntrySymbol,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Sets the callback used to resolve FFI native functions for a library.\n The resolved functions are expected to be a C function pointer of the\n correct signature (as specified in the `@Native<NFT>()` function\n annotation in Dart code).\n\n NOTE: This is an experimental feature and might change in the future.\n\n \\param library A library.\n \\param resolver A native function resolver.\n\n \\return A valid handle if the native resolver was set successfully."]
    pub fn Dart_SetFfiNativeResolver(
        library: Dart_Handle,
        resolver: Dart_FfiNativeResolver,
    ) -> Dart_Handle;
}
#[doc = " Callback provided by the embedder that is used by the VM to resolve asset\n paths.\n\n The VM is responsible for looking up the asset path with the asset id in the\n kernel mapping. The embedder is responsible for providing the asset mapping\n during kernel compilation and using the asset path to return a library handle\n in this function.\n\n \\param path The string in the asset path as passed in native_assets.yaml\n             during kernel compilation.\n\n \\param error Returns NULL if successful, an error message otherwise. The\n   caller is responsible for calling free() on the error message.\n\n \\return The library handle. If |error| is not-null, the return value is\n         undefined."]
pub type Dart_NativeAssetsDlopenCallback = ::std::option::Option<
    unsafe extern "C" fn(
        path: *const ::std::os::raw::c_char,
        error: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void,
>;
pub type Dart_NativeAssetsDlopenCallbackNoPath = ::std::option::Option<
    unsafe extern "C" fn(error: *mut *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_void,
>;
#[doc = " Callback provided by the embedder that is used by the VM to resolve asset\n ids.\n\n The embedder can freely chose how to bundle asset id to asset path mappings\n and how to perform this lookup.\n\n If the embedder provides this callback, it must also provide\n `Dart_NativeAssetsAvailableAssets`.\n\n If provided, takes prescedence over `Dart_NativeAssetsDlopenCallback`.\n\n \\param path The asset id requested in the `@Native` external function.\n\n \\param error Returns NULL if successful, an error message otherwise. The\n   caller is responsible for calling free() on the error message.\n\n \\return The library handle. If |error| is not-null, the return value is\n         undefined."]
pub type Dart_NativeAssetsDlopenAssetId = ::std::option::Option<
    unsafe extern "C" fn(
        asset_id: *const ::std::os::raw::c_char,
        error: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void,
>;
#[doc = " Callback provided by the embedder that is used  by the VM to request a\n description of the available assets\n\n \\return A malloced string containing all asset ids. The caller must free this\n   string."]
pub type Dart_NativeAssetsAvailableAssets =
    ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_char>;
#[doc = " Callback provided by the embedder that is used by the VM to lookup symbols\n in native code assets.\n If no callback is provided, using `@Native`s with `native_asset.yaml`s will\n fail.\n\n \\param handle The library handle returned from a\n               `Dart_NativeAssetsDlopenCallback` or\n               `Dart_NativeAssetsDlopenCallbackNoPath`.\n\n \\param symbol The symbol to look up. Is a string.\n\n \\param error Returns NULL if creation is successful, an error message\n   otherwise. The caller is responsible for calling free() on the error\n   message.\n\n \\return The symbol address. If |error| is not-null, the return value is\n         undefined."]
pub type Dart_NativeAssetsDlsymCallback = ::std::option::Option<
    unsafe extern "C" fn(
        handle: *mut ::std::os::raw::c_void,
        symbol: *const ::std::os::raw::c_char,
        error: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NativeAssetsApi {
    pub dlopen_absolute: Dart_NativeAssetsDlopenCallback,
    pub dlopen_relative: Dart_NativeAssetsDlopenCallback,
    pub dlopen_system: Dart_NativeAssetsDlopenCallback,
    pub dlopen_process: Dart_NativeAssetsDlopenCallbackNoPath,
    pub dlopen_executable: Dart_NativeAssetsDlopenCallbackNoPath,
    pub dlsym: Dart_NativeAssetsDlsymCallback,
    pub dlopen: Dart_NativeAssetsDlopenAssetId,
    pub available_assets: Dart_NativeAssetsAvailableAssets,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of NativeAssetsApi"][::std::mem::size_of::<NativeAssetsApi>() - 64usize];
    ["Alignment of NativeAssetsApi"][::std::mem::align_of::<NativeAssetsApi>() - 8usize];
    ["Offset of field: NativeAssetsApi::dlopen_absolute"]
        [::std::mem::offset_of!(NativeAssetsApi, dlopen_absolute) - 0usize];
    ["Offset of field: NativeAssetsApi::dlopen_relative"]
        [::std::mem::offset_of!(NativeAssetsApi, dlopen_relative) - 8usize];
    ["Offset of field: NativeAssetsApi::dlopen_system"]
        [::std::mem::offset_of!(NativeAssetsApi, dlopen_system) - 16usize];
    ["Offset of field: NativeAssetsApi::dlopen_process"]
        [::std::mem::offset_of!(NativeAssetsApi, dlopen_process) - 24usize];
    ["Offset of field: NativeAssetsApi::dlopen_executable"]
        [::std::mem::offset_of!(NativeAssetsApi, dlopen_executable) - 32usize];
    ["Offset of field: NativeAssetsApi::dlsym"]
        [::std::mem::offset_of!(NativeAssetsApi, dlsym) - 40usize];
    ["Offset of field: NativeAssetsApi::dlopen"]
        [::std::mem::offset_of!(NativeAssetsApi, dlopen) - 48usize];
    ["Offset of field: NativeAssetsApi::available_assets"]
        [::std::mem::offset_of!(NativeAssetsApi, available_assets) - 56usize];
};
unsafe extern "C" {
    #[doc = " Initializes native asset resolution for the current isolate group.\n\n The caller is responsible for ensuring this is called right after isolate\n group creation, and before running any dart code (or spawning isolates).\n\n @param native_assets_api The callbacks used by native assets resolution.\n                          The VM does not take ownership of the parameter,\n                          it can be freed immediately after the call."]
    pub fn Dart_InitializeNativeAssetsResolver(native_assets_api: *mut NativeAssetsApi);
}
pub const Dart_LibraryTag_Dart_kCanonicalizeUrl: Dart_LibraryTag = 0;
pub const Dart_LibraryTag_Dart_kImportTag: Dart_LibraryTag = 1;
pub const Dart_LibraryTag_Dart_kKernelTag: Dart_LibraryTag = 2;
pub type Dart_LibraryTag = ::std::os::raw::c_uint;
#[doc = " The library tag handler is a multi-purpose callback provided by the\n embedder to the Dart VM. The embedder implements the tag handler to\n provide the ability to load Dart scripts and imports.\n\n -- TAGS --\n\n Dart_kCanonicalizeUrl\n\n This tag indicates that the embedder should canonicalize 'url' with\n respect to 'library'.  For most embedders, this is resolving the `url`\n relative to the `library`s url (see `Dart_LibraryUrl`).\n\n Dart_kImportTag\n\n This tag is used to load a library from IsolateMirror.loadUri. The embedder\n should call Dart_LoadLibraryFromKernel to provide the library to the VM. The\n return value should be an error or library (the result from\n Dart_LoadLibraryFromKernel).\n\n Dart_kKernelTag\n\n This tag is used to load the intermediate file (kernel) generated by\n the Dart front end. This tag is typically used when a 'hot-reload'\n of an application is needed and the VM is 'use dart front end' mode.\n The dart front end typically compiles all the scripts, imports and part\n files into one intermediate file hence we don't use the source/import or\n script tags. The return value should be an error or a TypedData containing\n the kernel bytes.\n"]
pub type Dart_LibraryTagHandler = ::std::option::Option<
    unsafe extern "C" fn(
        tag: Dart_LibraryTag,
        library_or_package_map_url: Dart_Handle,
        url: Dart_Handle,
    ) -> Dart_Handle,
>;
unsafe extern "C" {
    #[doc = " Sets library tag handler for the current isolate. This handler is\n used to handle the various tags encountered while loading libraries\n or scripts in the isolate.\n\n \\param handler Handler code to be used for handling the various tags\n   encountered while loading libraries or scripts in the isolate.\n\n \\return If no error occurs, the handler is set for the isolate.\n   Otherwise an error handle is returned.\n\n TODO(turnidge): Document."]
    pub fn Dart_SetLibraryTagHandler(handler: Dart_LibraryTagHandler) -> Dart_Handle;
}
#[doc = " Handles deferred loading requests. When this handler is invoked, it should\n eventually load the deferred loading unit with the given id and call\n Dart_DeferredLoadComplete or Dart_DeferredLoadCompleteError. It is\n recommended that the loading occur asynchronously, but it is permitted to\n call Dart_DeferredLoadComplete or Dart_DeferredLoadCompleteError before the\n handler returns.\n\n If an error is returned, it will be propagated through\n `prefix.loadLibrary()`. This is useful for synchronous\n implementations, which must propagate any unwind errors from\n Dart_DeferredLoadComplete or Dart_DeferredLoadComplete. Otherwise the handler\n should return a non-error such as `Dart_Null()`."]
pub type Dart_DeferredLoadHandler =
    ::std::option::Option<unsafe extern "C" fn(loading_unit_id: isize) -> Dart_Handle>;
unsafe extern "C" {
    #[doc = " Sets the deferred load handler for the current isolate. This handler is\n used to handle loading deferred imports in an AppJIT or AppAOT program."]
    pub fn Dart_SetDeferredLoadHandler(handler: Dart_DeferredLoadHandler) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Notifies the VM that a deferred load completed successfully. This function\n will eventually cause the corresponding `prefix.loadLibrary()` futures to\n complete.\n\n Requires the current isolate to be the same current isolate during the\n invocation of the Dart_DeferredLoadHandler."]
    pub fn Dart_DeferredLoadComplete(
        loading_unit_id: isize,
        snapshot_data: *const u8,
        snapshot_instructions: *const u8,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Notifies the VM that a deferred load failed. This function\n will eventually cause the corresponding `prefix.loadLibrary()` futures to\n complete with an error.\n\n If `transient` is true, future invocations of `prefix.loadLibrary()` will\n trigger new load requests. If false, futures invocation will complete with\n the same error.\n\n Requires the current isolate to be the same current isolate during the\n invocation of the Dart_DeferredLoadHandler."]
    pub fn Dart_DeferredLoadCompleteError(
        loading_unit_id: isize,
        error_message: *const ::std::os::raw::c_char,
        transient: bool,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Loads the root library for the current isolate.\n\n Requires there to be no current root library.\n\n \\param kernel_buffer A buffer which contains a kernel binary (see\n     pkg/kernel/binary.md). Must remain valid until isolate group shutdown.\n \\param kernel_size Length of the passed in buffer.\n\n \\return A handle to the root library, or an error."]
    pub fn Dart_LoadScriptFromKernel(kernel_buffer: *const u8, kernel_size: isize) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Gets the library for the root script for the current isolate.\n\n If the root script has not yet been set for the current isolate,\n this function returns Dart_Null().  This function never returns an\n error handle.\n\n \\return Returns the root Library for the current isolate or Dart_Null()."]
    pub fn Dart_RootLibrary() -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Sets the root library for the current isolate.\n\n \\return Returns an error handle if `library` is not a library handle."]
    pub fn Dart_SetRootLibrary(library: Dart_Handle) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Lookup or instantiate a legacy type by name and type arguments from a\n Library.\n\n \\param library The library containing the class or interface.\n \\param class_name The class name for the type.\n \\param number_of_type_arguments Number of type arguments.\n   For non parametric types the number of type arguments would be 0.\n \\param type_arguments Pointer to an array of type arguments.\n   For non parametric types a NULL would be passed in for this argument.\n\n \\return If no error occurs, the type is returned.\n   Otherwise an error handle is returned."]
    pub fn Dart_GetType(
        library: Dart_Handle,
        class_name: Dart_Handle,
        number_of_type_arguments: isize,
        type_arguments: *mut Dart_Handle,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Lookup or instantiate a nullable type by name and type arguments from\n Library.\n\n \\param library The library containing the class or interface.\n \\param class_name The class name for the type.\n \\param number_of_type_arguments Number of type arguments.\n   For non parametric types the number of type arguments would be 0.\n \\param type_arguments Pointer to an array of type arguments.\n   For non parametric types a NULL would be passed in for this argument.\n\n \\return If no error occurs, the type is returned.\n   Otherwise an error handle is returned."]
    pub fn Dart_GetNullableType(
        library: Dart_Handle,
        class_name: Dart_Handle,
        number_of_type_arguments: isize,
        type_arguments: *mut Dart_Handle,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Lookup or instantiate a non-nullable type by name and type arguments from\n Library.\n\n \\param library The library containing the class or interface.\n \\param class_name The class name for the type.\n \\param number_of_type_arguments Number of type arguments.\n   For non parametric types the number of type arguments would be 0.\n \\param type_arguments Pointer to an array of type arguments.\n   For non parametric types a NULL would be passed in for this argument.\n\n \\return If no error occurs, the type is returned.\n   Otherwise an error handle is returned."]
    pub fn Dart_GetNonNullableType(
        library: Dart_Handle,
        class_name: Dart_Handle,
        number_of_type_arguments: isize,
        type_arguments: *mut Dart_Handle,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Creates a nullable version of the provided type.\n\n \\param type The type to be converted to a nullable type.\n\n \\return If no error occurs, a nullable type is returned.\n   Otherwise an error handle is returned."]
    pub fn Dart_TypeToNullableType(type_: Dart_Handle) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Creates a non-nullable version of the provided type.\n\n \\param type The type to be converted to a non-nullable type.\n\n \\return If no error occurs, a non-nullable type is returned.\n   Otherwise an error handle is returned."]
    pub fn Dart_TypeToNonNullableType(type_: Dart_Handle) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " A type's nullability.\n\n \\param type A Dart type.\n \\param result An out parameter containing the result of the check. True if\n the type is of the specified nullability, false otherwise.\n\n \\return Returns an error handle if type is not of type Type."]
    pub fn Dart_IsNullableType(type_: Dart_Handle, result: *mut bool) -> Dart_Handle;
}
unsafe extern "C" {
    pub fn Dart_IsNonNullableType(type_: Dart_Handle, result: *mut bool) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Lookup a class or interface by name from a Library.\n\n \\param library The library containing the class or interface.\n \\param class_name The name of the class or interface.\n\n \\return If no error occurs, the class or interface is\n   returned. Otherwise an error handle is returned."]
    pub fn Dart_GetClass(library: Dart_Handle, class_name: Dart_Handle) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Returns an import path to a Library, such as \"file:///test.dart\" or\n \"dart:core\"."]
    pub fn Dart_LibraryUrl(library: Dart_Handle) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Returns a URL from which a Library was loaded."]
    pub fn Dart_LibraryResolvedUrl(library: Dart_Handle) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " \\return An array of libraries."]
    pub fn Dart_GetLoadedLibraries() -> Dart_Handle;
}
unsafe extern "C" {
    pub fn Dart_LookupLibrary(url: Dart_Handle) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Report an loading error for the library.\n\n \\param library The library that failed to load.\n \\param error The Dart error instance containing the load error.\n\n \\return If the VM handles the error, the return value is\n a null handle. If it doesn't handle the error, the error\n object is returned."]
    pub fn Dart_LibraryHandleError(library: Dart_Handle, error: Dart_Handle) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Called by the embedder to load a partial program. Does not set the root\n library.\n\n \\param kernel_buffer A buffer which contains a kernel binary (see\n     pkg/kernel/binary.md). Must remain valid until isolate shutdown.\n \\param kernel_buffer_size Length of the passed in buffer.\n\n \\return A handle to the main library of the compilation unit, or an error."]
    pub fn Dart_LoadLibraryFromKernel(
        kernel_buffer: *const u8,
        kernel_buffer_size: isize,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    pub fn Dart_LoadLibrary(kernel_buffer: Dart_Handle) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Indicates that all outstanding load requests have been satisfied.\n This finalizes all the new classes loaded and optionally completes\n deferred library futures.\n\n Requires there to be a current isolate.\n\n \\param complete_futures Specify true if all deferred library\n  futures should be completed, false otherwise.\n\n \\return Success if all classes have been finalized and deferred library\n   futures are completed. Otherwise, returns an error."]
    pub fn Dart_FinalizeLoading(complete_futures: bool) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Returns the value of peer field of 'object' in 'peer'.\n\n \\param object An object.\n \\param peer An out parameter that returns the value of the peer\n   field.\n\n \\return Returns an error if 'object' is a subtype of Null, num, or\n   bool."]
    pub fn Dart_GetPeer(object: Dart_Handle, peer: *mut *mut ::std::os::raw::c_void)
    -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Sets the value of the peer field of 'object' to the value of\n 'peer'.\n\n \\param object An object.\n \\param peer A value to store in the peer field.\n\n \\return Returns an error if 'object' is a subtype of Null, num, or\n   bool."]
    pub fn Dart_SetPeer(object: Dart_Handle, peer: *mut ::std::os::raw::c_void) -> Dart_Handle;
}
pub const Dart_KernelCompilationStatus_Dart_KernelCompilationStatus_Unknown:
    Dart_KernelCompilationStatus = -1;
pub const Dart_KernelCompilationStatus_Dart_KernelCompilationStatus_Ok:
    Dart_KernelCompilationStatus = 0;
pub const Dart_KernelCompilationStatus_Dart_KernelCompilationStatus_Error:
    Dart_KernelCompilationStatus = 1;
pub const Dart_KernelCompilationStatus_Dart_KernelCompilationStatus_Crash:
    Dart_KernelCompilationStatus = 2;
pub const Dart_KernelCompilationStatus_Dart_KernelCompilationStatus_MsgFailed:
    Dart_KernelCompilationStatus = 3;
#[doc = " Experimental support for Dart to Kernel parser isolate.\n\n TODO(hausner): Document finalized interface.\n"]
pub type Dart_KernelCompilationStatus = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dart_KernelCompilationResult {
    pub status: Dart_KernelCompilationStatus,
    pub error: *mut ::std::os::raw::c_char,
    pub kernel: *mut u8,
    pub kernel_size: isize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Dart_KernelCompilationResult"]
        [::std::mem::size_of::<Dart_KernelCompilationResult>() - 32usize];
    ["Alignment of Dart_KernelCompilationResult"]
        [::std::mem::align_of::<Dart_KernelCompilationResult>() - 8usize];
    ["Offset of field: Dart_KernelCompilationResult::status"]
        [::std::mem::offset_of!(Dart_KernelCompilationResult, status) - 0usize];
    ["Offset of field: Dart_KernelCompilationResult::error"]
        [::std::mem::offset_of!(Dart_KernelCompilationResult, error) - 8usize];
    ["Offset of field: Dart_KernelCompilationResult::kernel"]
        [::std::mem::offset_of!(Dart_KernelCompilationResult, kernel) - 16usize];
    ["Offset of field: Dart_KernelCompilationResult::kernel_size"]
        [::std::mem::offset_of!(Dart_KernelCompilationResult, kernel_size) - 24usize];
};
pub const Dart_KernelCompilationVerbosityLevel_Dart_KernelCompilationVerbosityLevel_Error:
    Dart_KernelCompilationVerbosityLevel = 0;
pub const Dart_KernelCompilationVerbosityLevel_Dart_KernelCompilationVerbosityLevel_Warning:
    Dart_KernelCompilationVerbosityLevel = 1;
pub const Dart_KernelCompilationVerbosityLevel_Dart_KernelCompilationVerbosityLevel_Info:
    Dart_KernelCompilationVerbosityLevel = 2;
pub const Dart_KernelCompilationVerbosityLevel_Dart_KernelCompilationVerbosityLevel_All:
    Dart_KernelCompilationVerbosityLevel = 3;
pub type Dart_KernelCompilationVerbosityLevel = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn Dart_IsKernelIsolate(isolate: Dart_Isolate) -> bool;
}
unsafe extern "C" {
    pub fn Dart_KernelIsolateIsRunning() -> bool;
}
unsafe extern "C" {
    pub fn Dart_KernelPort() -> Dart_Port;
}
unsafe extern "C" {
    #[doc = " Compiles the given `script_uri` to a kernel file.\n\n \\param platform_kernel A buffer containing the kernel of the platform (e.g.\n `vm_platform_strong.dill`). The VM does not take ownership of this memory.\n\n \\param platform_kernel_size The length of the platform_kernel buffer.\n\n \\param snapshot_compile Set to `true` when the compilation is for a snapshot.\n This is used by the frontend to determine if compilation related information\n should be printed to console (e.g., null safety mode).\n\n \\param embed_sources Set to `true` when sources should be embedded in the\n kernel file.\n\n \\param verbosity Specifies the logging behavior of the kernel compilation\n service.\n\n \\return Returns the result of the compilation.\n\n On a successful compilation the returned [Dart_KernelCompilationResult] has\n a status of [Dart_KernelCompilationStatus_Ok] and the `kernel`/`kernel_size`\n fields are set. The caller takes ownership of the malloc()ed buffer.\n\n On a failed compilation the `error` might be set describing the reason for\n the failed compilation. The caller takes ownership of the malloc()ed\n error.\n\n Requires there to be a current isolate."]
    pub fn Dart_CompileToKernel(
        script_uri: *const ::std::os::raw::c_char,
        platform_kernel: *const u8,
        platform_kernel_size: isize,
        incremental_compile: bool,
        snapshot_compile: bool,
        embed_sources: bool,
        package_config: *const ::std::os::raw::c_char,
        verbosity: Dart_KernelCompilationVerbosityLevel,
    ) -> Dart_KernelCompilationResult;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dart_SourceFile {
    pub uri: *const ::std::os::raw::c_char,
    pub source: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Dart_SourceFile"][::std::mem::size_of::<Dart_SourceFile>() - 16usize];
    ["Alignment of Dart_SourceFile"][::std::mem::align_of::<Dart_SourceFile>() - 8usize];
    ["Offset of field: Dart_SourceFile::uri"]
        [::std::mem::offset_of!(Dart_SourceFile, uri) - 0usize];
    ["Offset of field: Dart_SourceFile::source"]
        [::std::mem::offset_of!(Dart_SourceFile, source) - 8usize];
};
unsafe extern "C" {
    pub fn Dart_KernelListDependencies() -> Dart_KernelCompilationResult;
}
unsafe extern "C" {
    #[doc = " Sets the kernel buffer which will be used to load Dart SDK sources\n dynamically at runtime.\n\n \\param platform_kernel A buffer containing kernel which has sources for the\n Dart SDK populated. Note: The VM does not take ownership of this memory.\n\n \\param platform_kernel_size The length of the platform_kernel buffer."]
    pub fn Dart_SetDartLibrarySourcesKernel(
        platform_kernel: *const u8,
        platform_kernel_size: isize,
    );
}
unsafe extern "C" {
    #[doc = " Always return true as the VM only supports strong null safety."]
    pub fn Dart_DetectNullSafety(
        script_uri: *const ::std::os::raw::c_char,
        package_config: *const ::std::os::raw::c_char,
        original_working_directory: *const ::std::os::raw::c_char,
        snapshot_data: *const u8,
        snapshot_instructions: *const u8,
        kernel_buffer: *const u8,
        kernel_buffer_size: isize,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns true if isolate is the service isolate.\n\n \\param isolate An isolate\n\n \\return Returns true if 'isolate' is the service isolate."]
    pub fn Dart_IsServiceIsolate(isolate: Dart_Isolate) -> bool;
}
unsafe extern "C" {
    #[doc = " Writes the CPU profile to the timeline as a series of 'instant' events.\n\n Note that this is an expensive operation.\n\n \\param main_port The main port of the Isolate whose profile samples to write.\n \\param error An optional error, must be free()ed by caller.\n\n \\return Returns true if the profile is successfully written and false\n         otherwise."]
    pub fn Dart_WriteProfileToTimeline(
        main_port: Dart_Port,
        error: *mut *mut ::std::os::raw::c_char,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Compiles all functions reachable from entry points and marks\n the isolate to disallow future compilation.\n\n Entry points should be specified using `@pragma(\"vm:entry-point\")`\n annotation.\n\n \\return An error handle if a compilation error or runtime error running const\n constructors was encountered."]
    pub fn Dart_Precompile() -> Dart_Handle;
}
pub type Dart_CreateLoadingUnitCallback = ::std::option::Option<
    unsafe extern "C" fn(
        callback_data: *mut ::std::os::raw::c_void,
        loading_unit_id: isize,
        write_callback_data: *mut *mut ::std::os::raw::c_void,
        write_debug_callback_data: *mut *mut ::std::os::raw::c_void,
    ),
>;
pub type Dart_StreamingWriteCallback = ::std::option::Option<
    unsafe extern "C" fn(
        callback_data: *mut ::std::os::raw::c_void,
        buffer: *const u8,
        size: isize,
    ),
>;
pub type Dart_StreamingCloseCallback =
    ::std::option::Option<unsafe extern "C" fn(callback_data: *mut ::std::os::raw::c_void)>;
unsafe extern "C" {
    pub fn Dart_LoadingUnitLibraryUris(loading_unit_id: isize) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = "  Creates a precompiled snapshot.\n   - A root library must have been loaded.\n   - Dart_Precompile must have been called.\n\n  Outputs an assembly file defining the symbols listed in the definitions\n  above.\n\n  The assembly should be compiled as a static or shared library and linked or\n  loaded by the embedder. Running this snapshot requires a VM compiled with\n  DART_PRECOMPILED_SNAPSHOT. The kDartVmSnapshotData and\n  kDartVmSnapshotInstructions should be passed to Dart_Initialize. The\n  kDartIsolateSnapshotData and kDartIsolateSnapshotInstructions should be\n  passed to Dart_CreateIsolateGroup.\n\n  The callback will be invoked one or more times to provide the assembly code.\n\n  If stripped is true, then the assembly code will not include DWARF\n  debugging sections.\n\n  If debug_callback_data is provided, debug_callback_data will be used with\n  the callback to provide separate debugging information.\n\n  \\return A valid handle if no error occurs during the operation."]
    pub fn Dart_CreateAppAOTSnapshotAsAssembly(
        callback: Dart_StreamingWriteCallback,
        callback_data: *mut ::std::os::raw::c_void,
        stripped: bool,
        debug_callback_data: *mut ::std::os::raw::c_void,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    pub fn Dart_CreateAppAOTSnapshotAsAssemblies(
        next_callback: Dart_CreateLoadingUnitCallback,
        next_callback_data: *mut ::std::os::raw::c_void,
        stripped: bool,
        write_callback: Dart_StreamingWriteCallback,
        close_callback: Dart_StreamingCloseCallback,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = "  Creates a precompiled snapshot.\n   - A root library must have been loaded.\n   - Dart_Precompile must have been called.\n\n  Outputs an ELF shared library defining the symbols\n   - _kDartVmSnapshotData\n   - _kDartVmSnapshotInstructions\n   - _kDartIsolateSnapshotData\n   - _kDartIsolateSnapshotInstructions\n\n  The shared library should be dynamically loaded by the embedder.\n  Running this snapshot requires a VM compiled with DART_PRECOMPILED_SNAPSHOT.\n  The kDartVmSnapshotData and kDartVmSnapshotInstructions should be passed to\n  Dart_Initialize. The kDartIsolateSnapshotData and\n  kDartIsolateSnapshotInstructions should be passed to Dart_CreateIsolate.\n\n  The callback will be invoked one or more times to provide the binary output.\n\n  If stripped is true, then the binary output will not include DWARF\n  debugging sections.\n\n  If debug_callback_data is provided, debug_callback_data will be used with\n  the callback to provide separate debugging information.\n\n \\return A valid handle if no error occurs during the operation."]
    pub fn Dart_CreateAppAOTSnapshotAsElf(
        callback: Dart_StreamingWriteCallback,
        callback_data: *mut ::std::os::raw::c_void,
        stripped: bool,
        debug_callback_data: *mut ::std::os::raw::c_void,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    pub fn Dart_CreateAppAOTSnapshotAsElfs(
        next_callback: Dart_CreateLoadingUnitCallback,
        next_callback_data: *mut ::std::os::raw::c_void,
        stripped: bool,
        write_callback: Dart_StreamingWriteCallback,
        close_callback: Dart_StreamingCloseCallback,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = "  Like Dart_CreateAppAOTSnapshotAsAssembly, but only includes\n  kDartVmSnapshotData and kDartVmSnapshotInstructions. It also does\n  not strip DWARF information from the generated assembly or allow for\n  separate debug information."]
    pub fn Dart_CreateVMAOTSnapshotAsAssembly(
        callback: Dart_StreamingWriteCallback,
        callback_data: *mut ::std::os::raw::c_void,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Sorts the class-ids in depth first traversal order of the inheritance\n tree. This is a costly operation, but it can make method dispatch\n more efficient and is done before writing snapshots.\n\n \\return A valid handle if no error occurs during the operation."]
    pub fn Dart_SortClasses() -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = "  Creates a snapshot that caches compiled code and type feedback for faster\n  startup and quicker warmup in a subsequent process.\n\n  Outputs a snapshot in two pieces. The pieces should be passed to\n  Dart_CreateIsolateGroup in a VM using the same VM snapshot pieces used in the\n  current VM. The instructions piece must be loaded with read and execute\n  permissions; the data piece may be loaded as read-only.\n\n   - Requires the VM to have not been started with --precompilation.\n   - Not supported when targeting IA32.\n   - The VM writing the snapshot and the VM reading the snapshot must be the\n     same version, must be built in the same DEBUG/RELEASE/PRODUCT mode, must\n     be targeting the same architecture, and must both be in checked mode or\n     both in unchecked mode.\n\n  The buffers are scope allocated and are only valid until the next call to\n  Dart_ExitScope.\n\n \\return A valid handle if no error occurs during the operation."]
    pub fn Dart_CreateAppJITSnapshotAsBlobs(
        isolate_snapshot_data_buffer: *mut *mut u8,
        isolate_snapshot_data_size: *mut isize,
        isolate_snapshot_instructions_buffer: *mut *mut u8,
        isolate_snapshot_instructions_size: *mut isize,
    ) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = " Get obfuscation map for precompiled code.\n\n Obfuscation map is encoded as a JSON array of pairs (original name,\n obfuscated name).\n\n \\return Returns an error handler if the VM was built in a mode that does not\n support obfuscation."]
    pub fn Dart_GetObfuscationMap(buffer: *mut *mut u8, buffer_length: *mut isize) -> Dart_Handle;
}
unsafe extern "C" {
    #[doc = "  Returns whether the VM only supports running from precompiled snapshots and\n  not from any other kind of snapshot or from source (that is, the VM was\n  compiled with DART_PRECOMPILED_RUNTIME)."]
    pub fn Dart_IsPrecompiledRuntime() -> bool;
}
unsafe extern "C" {
    #[doc = "  Print a native stack trace. Used for crash handling.\n\n  If context is NULL, prints the current stack trace. Otherwise, context\n  should be a CONTEXT* (Windows) or ucontext_t* (POSIX) from a signal handler\n  running on the current thread."]
    pub fn Dart_DumpNativeStackTrace(context: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    #[doc = "  Indicate that the process is about to abort, and the Dart VM should not\n  attempt to cleanup resources."]
    pub fn Dart_PrepareToAbort();
}
#[doc = " Callback provided by the embedder that is used by the VM to\n produce footnotes appended to DWARF stack traces.\n\n Whenever VM formats a stack trace as a string it would call this callback\n passing raw program counters for each frame in the stack trace.\n\n Embedder can then return a string which if not-null will be appended to the\n formatted stack trace.\n\n Returned string is expected to be `malloc()` allocated. VM takes ownership\n of the returned string and will `free()` it.\n\n \\param addresses raw program counter addresses for each frame\n \\param count number of elements in the addresses array"]
pub type Dart_DwarfStackTraceFootnoteCallback = ::std::option::Option<
    unsafe extern "C" fn(
        addresses: *mut *mut ::std::os::raw::c_void,
        count: isize,
    ) -> *mut ::std::os::raw::c_char,
>;
unsafe extern "C" {
    #[doc = "  Configure DWARF stack trace footnote callback."]
    pub fn Dart_SetDwarfStackTraceFootnoteCallback(callback: Dart_DwarfStackTraceFootnoteCallback);
}
